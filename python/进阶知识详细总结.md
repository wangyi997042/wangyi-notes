
## 15. Python 进阶知识详细总结

### 15.1 装饰器（Decorator）
- 本质是一个函数，用于在不修改原函数代码的情况下，扩展函数功能。
- 常用于日志、权限校验、缓存等场景。
- 可以装饰函数、方法、类。

**函数装饰器示例：**
```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("函数开始执行")
        result = func(*args, **kwargs)
        print("函数执行结束")
        return result
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

**带参数的装饰器：**
```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def greet():
    print("Hi!")
greet()
```

---

### 15.2 生成器（Generator）详细总结

#### 一、什么是生成器？

- 生成器是 Python 中一种用于惰性生成数据的特殊迭代器。
- 生成器可以一次只生成一个值，节省内存，适合处理大数据流或无限序列。
- 生成器对象自动实现了 `__iter__()` 和 `__next__()` 方法，可以用于 for 循环等所有迭代场景。

- 生成器是高效、优雅的惰性数据生成工具，适合大数据、流式处理等场景。
- 推荐优先用生成器简化迭代器开发，提升代码性能和可读性。
---

#### 二、生成器的创建方式

##### 1. 生成器函数（使用 `yield`）

- 生成器函数是包含 `yield` 关键字的函数。
- 每次执行到 `yield` 时会暂停，返回一个值，下次迭代时从上次暂停处继续执行。

**示例：**
```python
def count_up(n):
    i = 0
    while i < n:
        yield i         # 暂停并返回当前值
        i += 1

gen = count_up(3)
print(next(gen))        # 0
print(next(gen))        # 1
print(next(gen))        # 2
# print(next(gen))      # StopIteration 异常
```

- 可以用 `for` 循环遍历生成器：
```python
for num in count_up(3):
    print(num)  # 输出 0 1 2
```

##### 2. 生成器表达式

- 语法类似列表推导式，只是把 `[]` 换成 `()`，返回一个生成器对象。
- 适合用于简单的惰性计算。

**示例：**
```python
gen = (x * x for x in range(5))
print(next(gen))  # 0
print(next(gen))  # 1
for i in gen:
    print(i)      # 4 9 16
```

---

#### 三、生成器的常用方法和属性

- `__iter__()`：返回自身，支持迭代协议。
- `__next__()`：返回下一个值，没有值时抛出 `StopIteration`。
- `send(value)`：向生成器内部传值，配合 `yield` 表达式使用。
- `close()`：关闭生成器，后续调用会抛出 `StopIteration`。
- `throw(type, value=None, traceback=None)`：在生成器内部抛出异常。

**示例：send 用法**
```python
def echo():
    x = yield "start"
    while True:
        x = yield x

g = echo()
print(next(g))        # start
print(g.send(10))     # 10
print(g.send(20))     # 20
```

---

#### 四、生成器的优点

- **节省内存**：只在需要时生成数据，不一次性占用大量内存。
- **惰性计算**：适合处理大文件、流式数据、无限序列等场景。
- **代码简洁**：用 `yield` 替代复杂的迭代器类实现。

---

#### 五、生成器与迭代器的关系

- 生成器是特殊的迭代器，自动实现了迭代器协议（`__iter__` 和 `__next__`）。
- 生成器函数和生成器表达式都可以直接用于 for 循环、`next()`、`list()` 等。

---

#### 六、常见应用场景

- 逐行读取大文件
- 无限序列（如斐波那契数列、自然数流）
- 流式数据处理、管道式数据处理
- 复杂数据流的分步处理

**示例：斐波那契数列生成器**
```python
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for num in fib(5):
    print(num)  # 0 1 1 2 3
```

---

#### 七、常见问题与注意事项

- 生成器只能遍历一次，遍历完后会抛出 `StopIteration`。
- 想要多次遍历，需要重新创建生成器对象。
- 用 `list(gen)` 可以一次性取出所有生成器内容，但会失去惰性优势。

---


### 15.3 迭代器（Iterator）详细总结

#### 一、什么是迭代器？

- 迭代器是实现了 `__iter__()` 和 `__next__()` 方法的对象。
- 可以用 `iter()` 得到迭代器对象，用 `next()` 获取下一个元素。
- 迭代器是“惰性”的，每次只生成一个元素，适合处理大数据流。

#### 二、常见内置迭代器

- 所有可迭代对象（如 list、tuple、str、dict、set、file 等）都可以通过 `iter()` 得到迭代器。
- 通过 `for ... in ...` 语句遍历时，Python 会自动调用 `iter()` 和 `next()`。

**示例：**
```python
lst = [1, 2, 3]
it = iter(lst)           # 得到迭代器对象
print(next(it))          # 1
print(next(it))          # 2
print(next(it))          # 3
# print(next(it))        # StopIteration 异常
```
- `iter(obj)`：返回一个迭代器对象，obj 必须实现了 `__iter__()` 方法。
- `next(it)`：返回迭代器 it 的下一个元素，若没有元素则抛出 `StopIteration` 异常。

#### 三、迭代器的核心方法

- `__iter__()`：返回迭代器对象本身，通常 `return self`。使对象可用于 for 循环等迭代环境。
- `__next__()`：返回下一个元素，没有元素时抛出 `StopIteration` 异常。每次调用返回序列的下一个值。

#### 四、自定义迭代器

自定义迭代器需要实现 `__iter__()` 和 `__next__()` 方法。

**示例：自定义一个类似 range 的迭代器**
```python
class MyRange:
    def __init__(self, n):
        self.i = 0
        self.n = n

    def __iter__(self):
        return self  # 返回自身作为迭代器对象

    def __next__(self):
        if self.i < self.n:
            val = self.i
            self.i += 1
            return val
        else:
            raise StopIteration  # 没有元素时抛出

for x in MyRange(3):
    print(x)  # 输出 0 1 2
```
- `__init__`：初始化迭代器的起始状态。
- `__iter__`：返回自身。
- `__next__`：返回下一个元素，结束时抛出 `StopIteration`。

#### 五、常用相关函数和属性

- `iter(obj)`：获取对象的迭代器（会调用 obj 的 `__iter__()` 方法）。
- `next(it, default)`：获取下一个元素，若无则返回 default（不写 default 会抛异常）。
- `isinstance(obj, collections.abc.Iterator)`：判断对象是否为迭代器类型。
- `zip()`：并行遍历多个序列，返回迭代器。
- `enumerate()`：遍历序列时同时获得索引和值，返回迭代器。
- `map(func, iterable)`：对序列中每个元素应用函数，返回迭代器。
- `filter(func, iterable)`：过滤序列，返回迭代器。
- `reversed(seq)`：反向迭代序列，返回迭代器。

**示例：**
```python
from collections.abc import Iterator

lst = [1, 2, 3]
it = iter(lst)
print(isinstance(it, Iterator))  # True，判断 it 是否为迭代器
print(next(it, "结束"))          # 1
print(next(it, "结束"))          # 2
print(next(it, "结束"))          # 3
print(next(it, "结束"))          # 结束（用 default 参数避免异常）

# enumerate 示例
for idx, val in enumerate(['a', 'b']):
    print(idx, val)  # 0 a  1 b

# zip 示例
for a, b in zip([1,2], ['x','y']):
    print(a, b)  # 1 x  2 y
```
- `collections.abc.Iterator`：标准库中的迭代器抽象基类，用于类型判断。
- `enumerate()`：返回 (索引, 元素) 元组的迭代器。
- `zip()`：将多个可迭代对象“打包”成元组，返回迭代器。

#### 六、迭代器与生成器的区别

- 生成器（generator）是特殊的迭代器，使用 `yield` 语句定义，自动实现了 `__iter__()` 和 `__next__()`。
- 迭代器可以用类实现，也可以用生成器函数快速实现。

**生成器示例：**
```python
def my_gen(n):
    i = 0
    while i < n:
        yield i
        i += 1

for x in my_gen(3):
    print(x)  # 0 1 2
```
- `yield`：每次返回一个值，函数暂停，下次迭代时从上次位置继续。

#### 七、文件对象也是迭代器

- 文件对象支持迭代，每次返回一行内容。
```python
with open("test.txt", "r", encoding="utf-8") as f:
    for line in f:
        print(line.strip())
```
- `for line in f`：每次迭代调用文件对象的 `__next__()`，返回下一行。

#### 八、常见问题与注意事项

- 迭代器只能遍历一次，遍历完后就失效了（StopIteration）。
- 如果需要多次遍历，请用可迭代对象（如 list、tuple）而不是迭代器。
- 用 `for` 循环遍历时，遇到 `StopIteration` 会自动结束循环。
- 迭代器对象通常没有 `len()`、`reversed()` 等方法。

#### 九、补充：可迭代对象与迭代器的关系

- 可迭代对象（Iterable）：实现了 `__iter__()` 方法的对象（如 list、str、dict 等），可以用 `for` 遍历。
- 迭代器（Iterator）：实现了 `__iter__()` 和 `__next__()` 方法的对象（如生成器、文件对象、用 iter() 得到的对象）。
- 可迭代对象通过 `iter()` 得到迭代器。

**判断示例：**
```python
from collections.abc import Iterable, Iterator

lst = [1, 2, 3]
print(isinstance(lst, Iterable))   # True，可迭代对象
print(isinstance(lst, Iterator))   # False，不是迭代器
it = iter(lst)
print(isinstance(it, Iterator))    # True，是迭代器
```
- `Iterable`：可迭代类型的抽象基类。
- `Iterator`：迭代器类型的抽象基类。

---

**总结：**
- 迭代器是实现了 `__iter__()` 和 `__next__()` 的对象，支持惰性遍历。
- 常用方法和属性：`iter()`、`next()`、`__iter__()`、`__next__()`、`StopIteration`。
- 迭代器只能遍历一次，遍历完后失效。
- 生成器是特殊的迭代器，推荐用 `yield` 快速实现。
- 文件、生成器、map/filter/zip/enumerate 等都返回迭代器。
- 判断是否为迭代器用 `isinstance(obj, Iterator)`。


### 15.4 推导式（Comprehension）
- 用于快速生成列表、字典、集合等。

**列表推导式：**
```python
lst = [x * 2 for x in range(5)]
print(lst)  # [0, 2, 4, 6, 8]
```

**字典推导式：**
```python
d = {x: x * x for x in range(3)}
print(d)  # {0: 0, 1: 1, 2: 4}
```

**集合推导式：**
```python
s = {x for x in [1, 2, 2, 3]}
print(s)  # {1, 2, 3}
```

---

### 15.5 多线程与多进程详细总结
#### 什么是进程？什么是线程？

##### 进程（Process）

- 进程是操作系统资源分配的最小单位，是正在运行的程序的实例。
- 每个进程拥有独立的内存空间、数据栈和其他系统资源。
- 进程之间相互独立，数据不共享，通信需通过进程间通信（如队列、管道等）。
- 适合 CPU 密集型任务（如大规模计算），多进程可以充分利用多核 CPU。

**示例：创建进程**
```python
from multiprocessing import Process

def worker():
    print("子进程正在运行")

if __name__ == "__main__":
    p = Process(target=worker)
    p.start()
    p.join()
```

---

##### 线程（Thread）

- 线程是操作系统调度的最小单位，是进程中的一个执行流。
- 同一进程内的多个线程共享内存空间和全局变量，数据交换方便。
- 线程间通信简单，但需注意线程安全（如加锁防止数据竞争）。
- 适合 I/O 密集型任务（如网络请求、文件读写），能提升程序响应速度。

**示例：创建线程**
```python
import threading

def worker():
    print("线程正在运行")

t = threading.Thread(target=worker)
t.start()
t.join()
```

---

#### 总结对比

| 对比项   | 进程（Process）           | 线程（Thread）           |
|----------|--------------------------|--------------------------|
| 内存空间 | 独立                     | 共享                     |
| 通信方式 | 队列、管道等              | 直接访问共享变量         |
| 开销     | 大，创建/切换较慢         | 小，创建/切换较快        |
| 适用场景 | CPU 密集型                | I/O 密集型               |
| 崩溃影响 | 互不影响                  | 线程崩溃可能影响整个进程 |

- 进程适合多核并行、数据隔离场景，线程适合高并发、数据共享场景。
- Python（CPython）多线程受 GIL 限制，CPU 密集型任务建议用多进程。

---

#### 一、多线程（threading）

- 多线程适合 I/O 密集型任务（如网络请求、文件读写、用户交互等），能提升程序的响应速度和资源利用率。
- 线程间共享内存空间，数据可以直接交换，但需注意线程安全问题（如数据竞争、死锁等）。

**常用 API 和属性及示例详细介绍：**

- `threading.Thread(target=func, args=(), name=None, daemon=None)`  
  创建线程对象，`target` 指定线程要执行的函数，`args` 为传递给函数的参数元组，`name` 可自定义线程名，`daemon` 是否为守护线程。
    ```python
    import threading
    def worker(num):
        print(f"线程 {num} 正在运行")
    t = threading.Thread(target=worker, args=(1,), name="MyThread", daemon=False)
    t.start()
    t.join()
    ```

- `start()`  
  启动线程，自动调用 `run()` 方法。每个线程只能启动一次。
    ```python
    t.start()
    ```

- `join(timeout=None)`  
  阻塞主线程，等待子线程结束后再继续执行后续代码。可选参数 `timeout` 指定等待的最长时间（秒）。
    ```python
    t.join()
    ```

- `is_alive()`  
  判断线程是否还在运行，返回 `True` 或 `False`。
    ```python
    print(t.is_alive())
    ```

- `setDaemon(True)` 或 `daemon=True`  
  设置为守护线程，主线程结束时守护线程自动退出。推荐直接用 `daemon=True`。
    ```python
    t = threading.Thread(target=worker, args=(2,))
    t.daemon = True
    t.start()
    ```

- `current_thread()`  
  获取当前正在运行的线程对象。常用于调试或区分不同线程。
    ```python
    print(threading.current_thread().name)
    ```

- `active_count()`  
  返回当前活动线程数（包括主线程）。
    ```python
    print(threading.active_count())
    ```

- `enumerate()`  
  返回所有活动线程的列表。
    ```python
    print(threading.enumerate())
    ```

- `name`  
  线程名属性，可读可写。用于标识线程。
    ```python
    t = threading.Thread(target=worker, args=(3,), name="WorkerThread")
    print(t.name)
    t.name = "NewName"
    print(t.name)
    ```

- `Lock()`  
  创建互斥锁对象，保证同一时刻只有一个线程访问共享资源。常用方法有：
    - `acquire(blocking=True, timeout=-1)`：手动加锁，阻塞等待或超时。
    - `release()`：手动释放锁。
    - 推荐用 `with lock:` 自动管理锁，防止死锁。
    ```python
    lock = threading.Lock()
    with lock:
        # 线程安全的代码块
        pass

    # 或手动加锁/释放
    lock.acquire()
    try:
        # 临界区
        pass
    finally:
        lock.release()
    ```

- `run()`  
  线程的执行体，默认调用 `target` 指定的函数。可在自定义线程类中重写。
    ```python
    class MyThread(threading.Thread):
        def run(self):
            print("自定义线程运行")
    t = MyThread()
    t.start()
    ```

---

**补充说明：**

- `Thread` 的常用属性：
    - `ident`：线程的唯一标识符（只读）。
    - `daemon`：是否为守护线程（布尔值）。
    - `native_id`：操作系统分配的线程ID（Python 3.8+）。
    - `is_alive()`：线程是否存活。
    - `name`：线程名。

- `Lock` 的常用方法：
    - `acquire(blocking=True, timeout=-1)`：加锁，支持阻塞/非阻塞和超时。
    - `release()`：释放锁。
    - 推荐用 `with lock:` 自动管理。

- 线程池（`concurrent.futures.ThreadPoolExecutor`）常用方法：
    - `submit(fn, *args, **kwargs)`：提交任务，返回 Future 对象。
    - `map(func, *iterables)`：并行处理可迭代对象。
    - `shutdown(wait=True)`：关闭线程池。

    ```python
    from concurrent.futures import ThreadPoolExecutor
    def task(x):
        return x * x
    with ThreadPoolExecutor(max_workers=3) as pool:
        futures = [pool.submit(task, i) for i in range(5)]
        for f in futures:
            print(f.result())
    ```

---

**总结：**
- `Thread` 用于创建和管理线程，常用属性有 `name`、`daemon`、`ident`。
- `start()` 启动线程，`join()` 等待线程结束，`is_alive()` 判断线程状态。
- `Lock` 用于线程同步，常用方法有 `acquire()`、`release()`，推荐用 `with lock:`。
- 线程池适合批量并发任务，`submit()`、`map()`、`shutdown()` 是常用方法。
- 合理使用这些 API，可以高效实现多线程并发与线程同步。



**示例1：函数式线程**
```python
import threading

def worker(num):
    print(f"线程 {num} 正在运行")

threads = []
for i in range(3):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()
for t in threads:
    t.join()  # 等待所有线程结束
```

**示例2：线程锁的使用（避免数据竞争）线程互斥锁（Lock）**
- 互斥锁（`threading.Lock`）用于保证同一时刻只有一个线程能访问共享资源，防止数据竞争和数据错乱，是多线程编程中最常用的同步原语。
- 适用于多个线程需要修改同一变量、写同一文件等场景。

**常用方法：**
- `lock = threading.Lock()`：创建锁对象。
- `lock.acquire()`：手动加锁，若已被其他线程占用则阻塞等待。
- `lock.release()`：手动释放锁。
- `with lock:`：推荐写法，自动加锁和释放，防止忘记释放导致死锁。

- `acquire()`：手动加锁，若锁已被其他线程占用则阻塞等待。
- `release()`：手动释放锁，释放后其他等待的线程才能获得锁。

**示例：手动加锁和释放锁**
```python
import threading

lock = threading.Lock()
count = 0

def add():
    global count
    for _ in range(10000):
        lock.acquire()      # 加锁
        try:
            count += 1
        finally:
            lock.release()  # 释放锁，确保即使出错也能释放

threads = [threading.Thread(target=add) for _ in range(5)]
for t in threads:
    t.start()
for t in threads:
    t.join()
print("最终count值：", count)
```
> 推荐用 `with lock:` 自动管理锁，避免忘记 `release()` 导致死锁。

```python
import threading

count = 0
lock = threading.Lock()

def add():
    global count
    for _ in range(100000):
        with lock:  # 自动加锁和释放
            count += 1

threads = [threading.Thread(target=add) for _ in range(5)]
for t in threads:
    t.start()
for t in threads:
    t.join()
print("最终count值：", count)
```
**注意事项：**
- 一定要保证每次加锁后都能释放锁，否则容易造成死锁（推荐用 `with lock:`）。
- 互斥锁只保证同一时刻一个线程进入临界区，不能解决线程间通信问题。
- 死锁：如果一个线程 acquire 后忘记 release，其他线程会永久阻塞。
- 互斥锁适合保护写操作，读多写少场景可考虑 `threading.RLock`（可重入锁）或 `threading.Semaphore`（信号量）。

---

**示例3：线程间通信（Queue）**
```python
import threading, queue

q = queue.Queue()

def producer():
    for i in range(5):
        q.put(i)
        print("生产：", i)

def consumer():
    while True:
        item = q.get()
        print("消费：", item)
        q.task_done()
        if item == 4:
            break

t1 = threading.Thread(target=producer)
t2 = threading.Thread(target=consumer)
t1.start()
t2.start()
t1.join()
t2.join()
```

**常见问题与注意事项：**
- 线程间数据共享需加锁，避免数据错乱。
- 死锁：多个线程互相等待对方释放锁，导致程序卡死。
- 线程不能被强制终止，只能自然结束。
- GIL（全局解释器锁）：CPython 解释器下，同一时刻只能有一个线程执行 Python 字节码，多线程适合 I/O 密集型任务，CPU 密集型建议用多进程。

---

#### 二、多进程（multiprocessing）

- 多进程适合 CPU 密集型任务（如大规模计算、数据处理等），每个进程有独立的内存空间，数据安全但开销大。
- 进程间数据独立，通信需用队列、管道等方式。

**常用 API 和属性及示例详细介绍：**

- `multiprocessing.Process(target=func, args=())`  
  创建进程对象，`target` 指定进程要执行的函数，`args` 为传递给函数的参数元组。每个 `Process` 实例代表一个独立的进程。
    ```python
    from multiprocessing import Process
    def worker(num):
        print(f"进程 {num} 正在运行")
    p = Process(target=worker, args=(1,))
    p.start()
    p.join()
    ```

- `start()`  
  启动进程，调用后会自动执行 `target` 指定的函数。每个进程只能启动一次。
    ```python
    p.start()
    ```

- `join()`  
  阻塞主进程，等待子进程结束后再继续执行后续代码。可选参数 `timeout` 指定等待的最长时间（秒）。
    ```python
    p.join()
    ```

- `is_alive()`  
  判断进程是否还在运行，返回 `True` 或 `False`。
    ```python
    print(p.is_alive())
    ```

- `Queue()`  
  进程安全的队列，用于进程间通信。支持 `put()`（放入数据）、`get()`（取出数据）、`empty()`（判断队列是否为空）、`full()`（判断队列是否满）、`qsize()`（队列长度）。
    ```python
    from multiprocessing import Queue
    q = Queue()
    q.put(123)         # 放入数据
    print(q.get())     # 取出数据
    print(q.empty())   # 判断是否为空
    ```

- `Pool(processes)`  
  进程池，批量管理多个进程。`processes` 指定池中进程数量。常用方法有：
    - `map(func, iterable)`：对可迭代对象中的每个元素用 func 处理，返回结果列表（阻塞）。
    - `apply(func, args=())`：同步执行 func，返回结果。
    - `apply_async(func, args=())`：异步执行 func，返回 AsyncResult。
    - `close()`：关闭进程池，不再接受新任务。
    - `join()`：等待进程池中所有进程执行完毕。

    **示例：**
    ```python
    from multiprocessing import Pool
    def square(x):
        return x * x
    with Pool(4) as pool:
        results = pool.map(square, range(5))  # [0, 1, 4, 9, 16]
        print(results)
    ```

**补充说明：**

- `Process` 的常用属性：
    - `pid`：进程的系统进程号。
    - `name`：进程名，默认如 "Process-1"，可自定义。
    - `exitcode`：进程退出时的状态码，正常为 0。
    - `daemon`：是否为守护进程，主进程退出时守护进程自动结束。

    ```python
    p = Process(target=worker, args=(1,), name="MyProcess")
    p.start()
    print(p.pid)         # 查看进程号
    print(p.name)        # 查看进程名
    print(p.daemon)      # 是否为守护进程
    p.join()
    print(p.exitcode)    # 查看退出码
    ```

- `Queue` 相关方法：
    - `put(item, block=True, timeout=None)`：放入数据，block=True 时队列满会阻塞。
    - `get(block=True, timeout=None)`：取出数据，block=True 时队列空会阻塞。
    - `qsize()`：返回队列当前大小。
    - `empty()`：判断队列是否为空。
    - `full()`：判断队列是否已满。

- `Pool` 相关方法：
    - `map_async(func, iterable)`：异步 map，返回 AsyncResult。
    - `apply_async(func, args=())`：异步执行，返回 AsyncResult，可用 `get()` 获取结果。
    - `terminate()`：立即终止进程池中的所有进程。

    ```python
    from multiprocessing import Pool
    def double(x):
        return x * 2
    with Pool(2) as pool:
        result = pool.apply_async(double, (10,))
        print(result.get())  # 20
    ```

---

**总结：**
- `Process` 用于创建和管理独立进程，常用属性有 `pid`、`name`、`daemon`、`exitcode`。
- `start()` 启动进程，`join()` 等待进程结束，`is_alive()` 判断进程状态。
- `Queue` 用于进程间安全通信，常用方法有 `put()`、`get()`、`empty()`、`full()`。
- `Pool` 用于批量管理进程，常用方法有 `map()`、`apply()`、`apply_async()`、`close()`、`join()`。




**示例1：基本多进程**
```python
from multiprocessing import Process

def worker(num):
    print(f"进程 {num} 正在运行")

if __name__ == "__main__":
    processes = []
    for i in range(3):
        p = Process(target=worker, args=(i,))
        processes.append(p)
        p.start()
    for p in processes:
        p.join()
```

**示例2：进程池 Pool**
```python
from multiprocessing import Pool

def square(x):
    return x * x

if __name__ == "__main__":
    with Pool(4) as pool:
        results = pool.map(square, range(5))
        print(results)  # [0, 1, 4, 9, 16]
```

**示例3：进程间通信（Queue）**
```python
from multiprocessing import Process, Queue

def producer(q):
    for i in range(5):
        q.put(i)

def consumer(q):
    while not q.empty():
        print(q.get())

if __name__ == "__main__":
    q = Queue()
    p1 = Process(target=producer, args=(q,))
    p2 = Process(target=consumer, args=(q,))
    p1.start()
    p1.join()
    p2.start()
    p2.join()
```

**常见问题与注意事项：**
- 进程间数据不共享，通信需用队列、管道等。
- 进程启动要写在 `if __name__ == "__main__":` 下，避免递归创建进程。
- 进程开销大，不适合大量小任务。
- 进程池适合批量任务处理。

---

#### 三、线程与进程的选择

- I/O 密集型任务（如网络、文件、数据库）：优先用多线程。
- CPU 密集型任务（如科学计算、加密、图像处理）：优先用多进程。
- 线程适合轻量级并发，进程适合重型并行。

---

#### 四、相关标准库 API 总结

- `threading`：线程管理、锁、条件变量、事件、定时器等。
- `queue.Queue`：线程安全队列。
- `multiprocessing`：进程管理、进程池、进程间通信。
- `concurrent.futures.ThreadPoolExecutor`、`ProcessPoolExecutor`：线程池/进程池高级接口。

---

**总结：**
- 多线程适合 I/O 密集型任务，注意线程安全和 GIL 限制。
- 多进程适合 CPU 密集型任务，进程间数据独立，通信需用队列等。
- 线程/进程池适合批量任务，异步编程适合高并发 I/O。
- 合理选择并发模型，提升程序性能和资源利用率。

---

### 15.6 协程（Coroutine）总结与介绍

#### 一、什么是协程？

- 协程是一种用户态的轻量级线程，又称微线程，可以在单线程内实现高并发。
- 协程通过挂起和恢复自身，实现多任务间的高效切换，适合大量 I/O 密集型、高并发场景。
- Python 3.5+ 原生支持协程，主要通过 `async def`、`await` 语法实现。

---

#### 二、协程的基本用法

- 用 `async def` 定义协程函数，返回协程对象。
- 用 `await` 等待另一个协程或异步操作，挂起当前协程，等待结果返回后恢复执行。
- 协程的调度和事件循环由 `asyncio` 标准库负责。

**基本示例：**
```python
import asyncio

async def hello():
    print("Hello ...")
    await asyncio.sleep(1)  # 模拟异步I/O操作
    print("... World!")

async def main():
    await asyncio.gather(hello(), hello())  # 并发运行两个协程

asyncio.run(main())
```
- `asyncio.run(main())`：启动事件循环，自动调度协程执行。
- `asyncio.sleep(1)`：异步休眠，不阻塞主线程。

---

#### 三、常用 API 和属性

- `async def`：定义协程函数。
- `await`：挂起当前协程，等待异步操作完成。
- `asyncio.run(coro)`：运行主协程，自动管理事件循环。
- `asyncio.gather(*coros)`：并发运行多个协程，等待全部完成。
- `asyncio.create_task(coro)`：创建任务对象，调度协程执行。
- `asyncio.sleep(seconds)`：异步休眠，常用于模拟 I/O。
- `asyncio.Queue`：异步队列，适合协程间通信。

**示例：并发任务与任务对象**
```python
import asyncio

async def task(n):
    print(f"任务{n}开始")
    await asyncio.sleep(1)
    print(f"任务{n}结束")

async def main():
    tasks = [asyncio.create_task(task(i)) for i in range(3)]
    await asyncio.gather(*tasks)

asyncio.run(main())
```

---

#### 四、协程与线程/进程的区别

| 对比项   | 协程（Coroutine） | 线程（Thread） | 进程（Process） |
|----------|------------------|----------------|-----------------|
| 切换方式 | 用户态，主动切换  | 内核态，系统调度 | 内核态，系统调度 |
| 内存开销 | 极小             | 较小           | 较大            |
| 并发性   | 高（适合I/O密集）| 较高           | 最高（多核）    |
| 数据隔离 | 共享（需注意同步）| 共享           | 独立            |
| 适用场景 | 高并发I/O密集    | I/O密集        | CPU密集         |

- 协程适合大量 I/O 并发，线程适合一般 I/O 并发，进程适合 CPU 密集型任务。

---

#### 五、常见应用场景

- 网络爬虫、高并发网络服务、异步 Web 框架（如 FastAPI、aiohttp）、异步数据库操作等。

---

#### 六、注意事项与常见问题

- 协程本质上是单线程，不能利用多核 CPU，CPU 密集型任务不适合用协程。
- 协程间共享全局变量，需注意同步问题（可用 `asyncio.Lock`）。
- 协程只能在事件循环中运行，不能直接用 `await` 在普通函数中。
- 协程与线程/进程可以结合使用，提升整体性能。

---

**总结：**
- 协程是高效的并发编程工具，适合高并发、I/O 密集型场景。
- 推荐用 `asyncio` 管理协程，掌握 `async/await` 语法和常用 API。
- 合理选择协程、线程、进程，提升 Python 程序的并发能力和资源利用率。

### 15.6.1 greenlet 总结

#### 一、什么是 greenlet？

- `greenlet` 是 Python 的一个第三方库，实现了更底层的协程（微线程）功能。
- 它允许在多个任务之间手动切换执行流（即“协作式多任务”），无需操作系统线程切换，效率极高。
- `greenlet` 不依赖事件循环，切换点完全由开发者控制，适合需要极致性能和手动切换场景。

---

#### 二、greenlet 的基本用法

- 通过 `greenlet.greenlet()` 创建 greenlet 对象，传入要运行的函数。
- 用 `switch()` 方法在不同 greenlet 之间切换。

**基本示例：**
```python
from greenlet import greenlet

def task1():
    print("任务1-开始")
    gr2.switch()
    print("任务1-恢复")
    gr2.switch()

def task2():
    print("任务2-开始")
    gr1.switch()
    print("任务2-结束")

gr1 = greenlet(task1)
gr2 = greenlet(task2)
gr1.switch()
```
**输出：**
```
任务1-开始
任务2-开始
任务1-恢复
任务2-结束
```

---

#### 三、常用 API 和属性

- `greenlet(func)`：创建 greenlet 对象，`func` 为要运行的函数。
- `switch(*args, **kwargs)`：切换到指定 greenlet 并传递参数。
- `parent`：指向父 greenlet（通常是主 greenlet）。
- `dead`：属性，判断 greenlet 是否已结束。
- `getcurrent()`：获取当前正在运行的 greenlet 对象。

**示例：**
```python
from greenlet import greenlet

def foo():
    print("foo step 1")
    gr2.switch()
    print("foo step 2")

def bar():
    print("bar step 1")
    gr1.switch()
    print("bar step 2")

gr1 = greenlet(foo)
gr2 = greenlet(bar)
print(greenlet.getcurrent())  # 当前greenlet对象
gr1.switch()
print("gr1 dead:", gr1.dead)
print("gr2 dead:", gr2.dead)
```

---

#### 四、greenlet 与 asyncio、线程的区别

| 对比项   | greenlet           | asyncio（协程） | 线程（threading） |
|----------|--------------------|-----------------|-------------------|
| 切换方式 | 手动切换           | 事件循环调度    | 操作系统调度      |
| 并发性   | 高（协作式）       | 高（协作式）    | 较高（抢占式）    |
| 适用场景 | 需要极致性能、手动切换 | 高并发I/O密集   | I/O密集、阻塞任务 |
| 数据隔离 | 共享               | 共享            | 共享              |
| 依赖     | C扩展库            | 标准库          | 标准库            |

- greenlet 适合底层库、网络框架（如 gevent）、需要手动切换的高性能场景。
- asyncio 适合结构化异步编程，推荐日常高并发开发。
- 线程适合阻塞型 I/O 或与第三方阻塞库交互。

---

#### 五、常见应用场景

- 网络库 gevent（基于 greenlet 实现高并发网络通信）
- 需要手动切换上下文的高性能异步框架
- 复杂协作式多任务调度

---

#### 六、注意事项

- greenlet 不是标准库，需要 `pip install greenlet`。
- 不能利用多核 CPU，适合单线程高并发。
- 切换点完全由开发者控制，易用性不如 asyncio，但性能极高。
- 不建议与线程/进程混用，避免上下文混乱。

---

**总结：**
- greenlet 提供了极致轻量级的协作式并发能力，适合底层高性能异步场景。
- 推荐日常异步开发优先用 asyncio，greenlet 适合特殊性能需求或底层库开发。

### 15.7 反射与元编程
- 反射：运行时动态获取对象信息，如 `getattr()`、`setattr()`、`hasattr()`。
- 元类（metaclass）：用于控制类的创建过程。

**反射示例：**
```python
class Foo:
    def bar(self):
        print("bar")

obj = Foo()
method = getattr(obj, "bar")
method()
```

**元类示例：**
```python
class MyMeta(type):
    def __new__(cls, name, bases, attrs):
        attrs['added_attr'] = 123
        return super().__new__(cls, name, bases, attrs)

class MyClass(metaclass=MyMeta):
    pass

print(MyClass.added_attr)  # 123
```

---
### 15.6.2 gevent 总结

#### 一、什么是 gevent？

- `gevent` 是基于 `greenlet` 实现的高性能 Python 并发库，提供了协作式多任务（协程）能力。
- 通过“猴子补丁”（monkey patching）自动将标准库中的阻塞 I/O 操作（如 socket、time.sleep 等）变为异步非阻塞，从而实现高并发。
- 适合高并发网络服务、爬虫、异步 I/O 等场景。

---

#### 二、gevent 的基本用法

- 用 `gevent.spawn()` 创建协程任务（Greenlet）。
- 用 `gevent.joinall()` 等待多个协程完成。
- 常用 `gevent.sleep()`、`gevent.queue.Queue` 等异步工具。

**基本示例：**
```python
import gevent

def task(n):
    for i in range(n):
        print(f"任务{i}")
        gevent.sleep(0.1)  # 模拟异步I/O

g1 = gevent.spawn(task, 3)
g2 = gevent.spawn(task, 2)
gevent.joinall([g1, g2])
```

---

#### 三、猴子补丁（monkey patch）

- 通过 `gevent.monkey.patch_all()`，自动将标准库的阻塞操作变为 gevent 协程可调度的异步操作。
- 常用于网络编程、socket、time.sleep、threading 等。

**示例：**
```python
from gevent import monkey; 
monkey.patch_all()
import socket
import gevent

def fetch(host):
    s = socket.socket()
    s.connect((host, 80))
    s.send(b'GET / HTTP/1.0\r\nHost: %b\r\n\r\n' % host.encode())
    data = s.recv(1024)
    print(f"{host}: {data[:20]}...")

gevent.joinall([
    gevent.spawn(fetch, 'www.python.org'),
    gevent.spawn(fetch, 'www.baidu.com'),
])
```

---

#### 四、常用 API 和属性

- `gevent.spawn(func, *args, **kwargs)`：创建 Greenlet 协程任务。
- `gevent.joinall(greenlets)`：等待多个协程完成。
- `gevent.sleep(seconds=0)`：让出执行权，模拟异步等待。
- `gevent.queue.Queue`：协程安全队列。
- `Greenlet` 对象的 `start()`、`join()`、`kill()`、`value` 等方法和属性。

---

#### 五、gevent 与 greenlet、asyncio、线程的区别

| 对比项   | gevent           | greenlet         | asyncio         | 线程（threading） |
|----------|------------------|------------------|-----------------|-------------------|
| 切换方式 | 自动（I/O钩子）  | 手动             | 事件循环        | 操作系统调度      |
| 并发性   | 高（协作式）     | 高（协作式）     | 高（协作式）    | 较高（抢占式）    |
| 适用场景 | 网络I/O高并发    | 底层手动切换     | 结构化异步      | 阻塞I/O           |
| 依赖     | 第三方库         | 第三方库         | 标准库          | 标准库            |

- gevent 适合高并发网络服务和异步 I/O，使用简单，生态成熟。
- greenlet 适合底层手动切换，gevent 在其基础上自动化了切换。
- asyncio 适合结构化异步编程，标准库支持。
- 线程适合阻塞型任务或与阻塞库交互。

---

#### 六、常见应用场景

- 高并发网络服务器（如 WebSocket、HTTP 服务）
- 网络爬虫、批量下载
- 异步 I/O、Socket 通信
- 替代多线程实现高并发

---

#### 七、注意事项

- gevent 不是标准库，需要 `pip install gevent`。
- 需用 `monkey.patch_all()` 补丁标准库，才能自动异步化阻塞操作。
- 不能利用多核 CPU，适合单进程高并发。
- 与 asyncio 不兼容，不能混用。
- 某些第三方库不支持猴子补丁，需注意兼容性。

---

**总结：**
- gevent 基于 greenlet 实现自动协作式并发，适合高并发网络与异步 I/O 场景。
- 推荐用 gevent 替代多线程实现高并发网络服务，使用简单，性能优异。
- 日常异步开发可优先考虑 asyncio，极致性能和兼容性需求可选 gevent。




### 15.8 上下文管理器（with语句）
- 用于资源管理，如文件、数据库连接等。
- 需实现 `__enter__` 和 `__exit__` 方法。

**示例：**
```python
class MyContext:
    def __enter__(self):
        print("进入上下文")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("退出上下文")

with MyContext():
    print("处理中")
```

---

### 15.9 日志与异常高级用法
- 日志：`logging` 模块，支持多级别日志、文件输出等。
- 自定义异常类，继承自 `Exception`。

**日志示例：**
```python
import logging
logging.basicConfig(level=logging.INFO)
logging.info("这是一条信息")
```

**自定义异常：**
```python
class MyError(Exception):
    pass

try:
    raise MyError("自定义异常")
except MyError as e:
    print(e)
```

---

### 15.10 常用标准库进阶
- `functools`（高阶函数与缓存）、`itertools`（迭代工具）、`collections`（高级数据结构）、`contextlib`（上下文管理）、`concurrent.futures`（并发执行）等。

**functools.partial 示例：**
```python
from functools import partial

def power(base, exp):
    return base ** exp

square = partial(power, exp=2)
print(square(3))  # 9
```

**itertools 示例：**
```python
import itertools
for x in itertools.permutations([1, 2, 3]):
    print(x)
```

---

## 16. os 模块常用属性和 API 总结

`os` 模块是 Python 标准库中用于操作操作系统功能的模块，提供了文件/目录操作、进程管理、环境变量、路径处理等丰富的接口，跨平台兼容性好。

---

#### 一、常用属性

- `os.name`：操作系统类型（'posix'、'nt'、'java'）。
- `os.sep`：路径分隔符（如 Unix 下为 `'/'`，Windows 下为 `'\\'`）。
- `os.linesep`：行结束符（如 Unix 下为 `'\n'`，Windows 下为 `'\r\n'`）。
- `os.pathsep`：环境变量分隔符（如 Unix 下为 `':'`，Windows 下为 `';'`）。
- `os.curdir`：当前目录符号（`.`）。
- `os.pardir`：父目录符号（`..`）。
- `os.environ`：环境变量字典。
- `os.extsep`：扩展名分隔符（`.`）。
- `os.devnull`：空设备文件名（如 `/dev/null` 或 `nul`）。

---

#### 二、文件与目录操作

- `os.getcwd()`：获取当前工作目录。
- `os.chdir(path)`：切换当前工作目录。
- `os.listdir(path='.')`：列出指定目录下的文件和文件夹。
- `os.mkdir(path, mode=0o777)`：创建单层目录。
- `os.makedirs(path, exist_ok=False)`：递归创建多层目录。
- `os.rmdir(path)`：删除单层空目录。
- `os.removedirs(path)`：递归删除多层空目录。
- `os.remove(path)`：删除文件。
- `os.rename(src, dst)`：重命名文件或目录。
- `os.replace(src, dst)`：原子性重命名或替换。
- `os.stat(path)`：获取文件或目录的状态信息（如大小、修改时间等）。
- `os.scandir(path='.')`：返回目录迭代器，比 listdir 更高效。
- `os.path.exists(path)`：判断路径是否存在。
- `os.path.isfile(path)`：判断是否为文件。
- `os.path.isdir(path)`：判断是否为目录。
- `os.path.getsize(path)`：获取文件大小（字节）。
- `os.path.abspath(path)`：获取绝对路径。
- `os.path.basename(path)`：获取文件名。
- `os.path.dirname(path)`：获取目录名。
- `os.path.splitext(path)`：分离文件名和扩展名。
- `os.path.join(path, *paths)`：拼接路径。

---

#### 三、进程管理

- `os.system(cmd)`：运行系统命令，返回退出码。
- `os.popen(cmd, mode='r')`：运行命令并返回文件对象。
- `os.exec*()`：执行新程序（如 `os.execvp`、`os.execl` 等）。
- `os.fork()`：Unix 下创建子进程。
- `os.spawn*()`：创建新进程（如 `os.spawnv`、`os.spawnl` 等）。
- `os.kill(pid, sig)`：向进程发送信号。
- `os.getpid()`：获取当前进程 ID。
- `os.getppid()`：获取父进程 ID。
- `os.getlogin()`：获取当前登录用户名。
- `os.exit(code)`：退出当前进程。

---

#### 四、权限与时间

- `os.chmod(path, mode)`：修改文件或目录权限。
- `os.chown(path, uid, gid)`：修改所有者（仅 Unix）。
- `os.utime(path, times)`：修改文件访问和修改时间。
- `os.umask(mask)`：设置当前进程的文件创建权限掩码。

---

#### 五、环境变量

- `os.environ`：环境变量字典，可直接读写。
    ```python
    os.environ['MY_VAR'] = 'value'
    print(os.environ.get('PATH'))
    ```
- `os.putenv(key, value)`：设置环境变量（不推荐，直接操作 os.environ 更常用）。
- `os.unsetenv(key)`：删除环境变量。

---

#### 六、路径操作（os.path 子模块）

- `os.path.abspath(path)`：获取绝对路径。
- `os.path.relpath(path, start=os.curdir)`：获取相对路径。
- `os.path.normpath(path)`：规范化路径。
- `os.path.expanduser(path)`：将 `~` 展开为用户主目录。
- `os.path.expandvars(path)`：展开环境变量。

---

#### 七、跨平台建议

- 路径拼接推荐用 `os.path.join()`。
- 路径判断用 `os.path.isfile()`、`os.path.isdir()`。
- 文件操作异常需用 `try...except` 捕获。

---

#### 八、常用示例（详细版）

```python
import os

# 1. 获取操作系统类型
print("操作系统类型 os.name：", os.name)  # 'posix'（类Unix）或 'nt'（Windows）

# 2. 获取当前工作目录
print("当前工作目录 os.getcwd()：", os.getcwd())

# 3. 创建和删除目录
os.mkdir('testdir')  # 创建单层目录
print("创建目录后，当前目录内容：", os.listdir('.'))
os.chdir('testdir')  # 切换到新目录
print("切换后工作目录：", os.getcwd())
os.chdir('..')       # 返回上级目录
os.rmdir('testdir')  # 删除空目录
print("删除目录后，当前目录内容：", os.listdir('.'))

# 4. 路径操作
print("绝对路径 os.path.abspath('.')：", os.path.abspath('.'))
print("路径拼接 os.path.join('folder', 'file.txt')：", os.path.join('folder', 'file.txt'))
print("分离扩展名 os.path.splitext('a.txt')：", os.path.splitext('a.txt'))
print("判断路径是否存在 os.path.exists('a.txt')：", os.path.exists('a.txt'))
print("判断是否为文件 os.path.isfile('a.txt')：", os.path.isfile('a.txt'))
print("判断是否为目录 os.path.isdir('folder')：", os.path.isdir('folder'))

# 5. 文件重命名与删除
# os.rename('old.txt', 'new.txt')
# os.remove('new.txt')

# 6. 获取文件大小（如文件存在）
# print("文件大小 os.path.getsize('a.txt')：", os.path.getsize('a.txt'))

# 7. 环境变量操作
print("PATH 环境变量 os.environ.get('PATH')：", os.environ.get('PATH'))
os.environ['MY_ENV'] = '123'
print("自定义环境变量 MY_ENV：", os.environ.get('MY_ENV'))

# 8. 运行系统命令
# os.system('ls' if os.name == 'posix' else 'dir')

# 9. 进程相关
print("当前进程ID os.getpid()：", os.getpid())
print("父进程ID os.getppid()：", os.getppid())

# 10. 其他常用属性
print("路径分隔符 os.sep：", os.sep)
print("行结束符 os.linesep：", repr(os.linesep))
print("环境变量分隔符 os.pathsep：", os.pathsep)
print("当前目录符号 os.curdir：", os.curdir)
print("父目录符号 os.pardir：", os.pardir)
```

**说明：**
- 路径操作推荐用 `os.path` 相关方法，保证跨平台兼容。
- 文件/目录操作建议加异常处理，防止因文件不存在等报错。
- 环境变量可直接通过 `os.environ` 字典读写。
- 进程相关操作如 `os.getpid()`、`os.system()` 适合脚本自动化场景。
- 更多高级用法可查阅官方文档。

---

**总结：**
- `os` 模块是 Python 操作系统接口的核心，涵盖文件、目录、进程、环境变量等操作。
- 推荐配合 `os.path` 进行路径处理，保证代码跨平台兼容。
- 详细 API 可查阅官方文档：https://docs.python.org/3/library/os.html


## 17. sys 模块常用属性和 API 总结

`sys` 模块是 Python 标准库中用于访问和操作 Python 解释器自身的一组接口，常用于脚本参数、环境、输入输出流、异常处理等场景。

---

#### 一、常用属性

- `sys.argv`：命令行参数列表，第一个元素是脚本名。
- `sys.path`：模块搜索路径列表（可动态添加/修改）。
- `sys.version`：Python 解释器版本信息字符串。
- `sys.version_info`：Python 版本信息元组（major, minor, micro, releaselevel, serial）。
- `sys.platform`：当前操作系统平台标识（如 'darwin'、'win32'、'linux'）。
- `sys.executable`：Python 解释器的绝对路径。
- `sys.modules`：已加载模块的字典。
- `sys.stdin` / `sys.stdout` / `sys.stderr`：标准输入/输出/错误流对象。
- `sys.byteorder`：本地字节序（'little' 或 'big'）。
- `sys.maxsize`：Python 支持的最大整数值。
- `sys.maxunicode`：最大 Unicode 码点。
- `sys.flags`：解释器启动时的标志集合。
- `sys.getdefaultencoding()`：获取当前默认字符串编码。
- `sys.builtin_module_names`：所有内建模块名称元组。

---

#### 二、常用 API

- `sys.exit([arg])`：退出 Python 解释器，可指定退出状态码。
- `sys.getsizeof(obj)`：返回对象占用的字节数。
- `sys.getrefcount(obj)`：返回对象的引用计数（比实际多 1）。
- `sys.setrecursionlimit(limit)`：设置最大递归深度。
- `sys.getrecursionlimit()`：获取最大递归深度。
- `sys.exc_info()`：获取当前异常信息（类型、值、回溯对象）。
- `sys.displayhook(value)`：交互式解释器输出钩子。
- `sys.setprofile(func)` / `sys.getprofile()`：设置/获取全局分析函数（用于性能分析）。
- `sys.settrace(func)` / `sys.gettrace()`：设置/获取全局跟踪函数（用于调试）。
- `sys.stdout.write(str)` / `sys.stderr.write(str)`：向标准输出/错误输出写内容。
- `sys.stdin.readline()`：从标准输入读取一行。

---

#### 三、常用示例（详细版）

```python
import sys

# 1. 命令行参数
print("命令行参数 sys.argv：", sys.argv)
# 运行 python script.py arg1 arg2 时，输出 ['script.py', 'arg1', 'arg2']

# 2. 模块搜索路径
print("模块搜索路径 sys.path：", sys.path)
# 可动态添加自定义模块路径
sys.path.append('/my/custom/path')
print("添加后 sys.path：", sys.path)

# 3. Python 版本信息
print("Python 版本 sys.version：", sys.version)
print("Python 版本详细 sys.version_info：", sys.version_info)

# 4. 平台和解释器路径
print("平台 sys.platform：", sys.platform)
print("解释器路径 sys.executable：", sys.executable)

# 5. 标准输入/输出/错误流
sys.stdout.write("Hello, stdout!\n")
sys.stderr.write("Hello, stderr!\n")
# 读取标准输入（如用户输入一行）
# line = sys.stdin.readline()
# print("输入内容：", line)

# 6. 获取对象占用的字节数
lst = [1, 2, 3]
print("列表占用字节数 sys.getsizeof(lst)：", sys.getsizeof(lst))

# 7. 获取对象引用计数
print("lst 引用计数 sys.getrefcount(lst)：", sys.getrefcount(lst))

# 8. 获取/设置递归深度
print("当前递归深度限制 sys.getrecursionlimit()：", sys.getrecursionlimit())
sys.setrecursionlimit(2000)
print("修改后递归深度限制：", sys.getrecursionlimit())

# 9. 获取当前异常信息（常用于 except 块）
try:
    1 / 0
except Exception:
    exc_type, exc_val, exc_tb = sys.exc_info()
    print("异常类型：", exc_type)
    print("异常值：", exc_val)

# 10. 退出 Python 解释器
# sys.exit(0)  # 正常退出，参数为状态码，0 表示正常

# 11. 其他常用属性
print("本地字节序 sys.byteorder：", sys.byteorder)
print("最大整数 sys.maxsize：", sys.maxsize)
print("内建模块 sys.builtin_module_names：", sys.builtin_module_names)
```

**说明：**
- `sys.argv` 适合命令行参数解析。
- `sys.path` 可动态添加模块搜索路径，便于导入自定义模块。
- `sys.stdin/stdout/stderr` 可实现输入输出重定向、日志重定向等高级用法。
- `sys.getsizeof`、`sys.getrefcount` 适合内存分析和调试。
- `sys.exit` 可用于脚本提前终止，常配合异常处理使用。
- `sys.exc_info()` 获取异常详细信息，便于日志记录和调试。

---

**总结：**
- `sys` 模块用于与 Python 解释器交互，常用于参数解析、环境控制、输入输出流、异常处理等。
- 推荐掌握 `sys.argv`、`sys.path`、`sys.exit`、`sys.stdin/stdout/stderr`、`sys.version` 等常用属性和方法。
- 详细 API 可查阅官方文档：https://docs.python.org/3/library/sys.html


---


## 18. time 模块常用属性和 API 总结

`time` 模块是 Python 标准库中用于时间获取、格式化、延时、时间戳处理等操作的模块，常用于计时、定时、时间转换等场景。

---

#### 一、常用属性

- `time.timezone`：本地与 UTC 时间的时差（秒，东区为负，西区为正）。
- `time.altzone`：夏令时下的本地与 UTC 时差（秒）。
- `time.daylight`：是否启用夏令时（0/1）。
- `time.tzname`：时区名称的元组（标准时/夏令时）。

---

#### 二、常用 API

- `time.time()`：返回当前时间的时间戳（1970纪元后经过的浮点秒数）。
- `time.localtime([secs])`：将时间戳转换为本地时间的 struct_time 对象，默认当前时间。
- `time.gmtime([secs])`：将时间戳转换为 UTC 时间的 struct_time 对象。
- `time.mktime(t)`：将 struct_time 转换为时间戳。
- `time.strftime(format, t=None)`：格式化时间为字符串，t 默认当前本地时间。
- `time.strptime(string, format)`：将字符串解析为 struct_time。
- `time.asctime([t])`：将 struct_time 转换为可读字符串，默认当前时间。
- `time.ctime([secs])`：将时间戳转换为可读字符串，默认当前时间。
- `time.sleep(secs)`：线程休眠指定秒数（可为浮点数）。
- `time.perf_counter()`：返回高精度计时器（适合计时）。
- `time.process_time()`：返回当前进程的 CPU 时间（不包括 sleep 时间）。
- `time.monotonic()`：返回单调时钟（不会倒退，适合计时）。
- `time.thread_time()`：返回当前线程的 CPU 时间（Python 3.7+）。

---

#### 三、常用 struct_time 属性

- `tm_year`：年
- `tm_mon`：月（1-12）
- `tm_mday`：日
- `tm_hour`：时
- `tm_min`：分
- `tm_sec`：秒
- `tm_wday`：星期（0-6，周一为0）
- `tm_yday`：一年中的第几天（1-366）
- `tm_isdst`：是否为夏令时（1/0/-1）

---

#### 四、常用示例（详细版）

```python
import time

# 1. 获取当前时间戳（1970年1月1日以来的秒数，float类型）
print("当前时间戳：", time.time())

# 2. 获取本地时间的 struct_time 对象
local_struct = time.localtime()
print("本地时间 struct_time：", local_struct)

# 3. 获取 UTC 时间的 struct_time 对象
utc_struct = time.gmtime()
print("UTC 时间 struct_time：", utc_struct)

# 4. struct_time 转为格式化字符串
print("格式化本地时间：", time.strftime("%Y-%m-%d %H:%M:%S", local_struct))

# 5. 字符串转 struct_time
str_time = "2025-06-20 12:30:00"
struct_time = time.strptime(str_time, "%Y-%m-%d %H:%M:%S")
print("字符串转 struct_time：", struct_time)

# 6. struct_time 转为时间戳
timestamp = time.mktime(struct_time)
print("struct_time 转时间戳：", timestamp)

# 7. 时间戳转为可读字符串
print("ctime：", time.ctime(timestamp))

# 8. struct_time 转为可读字符串
print("asctime：", time.asctime(local_struct))

# 9. 线程休眠1秒
print("开始休眠1秒")
time.sleep(1)
print("休眠结束")

# 10. 高精度计时（适合性能测试）
start = time.perf_counter()
for _ in range(1000000):
    pass
end = time.perf_counter()
print("高精度计时耗时：", end - start, "秒")

# 11. 单调时钟（不会倒退，适合计时）
print("monotonic：", time.monotonic())

# 12. 当前进程CPU时间
print("process_time：", time.process_time())

# 13. 当前线程CPU时间（Python 3.7+）
if hasattr(time, "thread_time"):
    print("thread_time：", time.thread_time())
```

**说明：**
- `struct_time` 是 time 模块的核心时间结构，属性如 tm_year、tm_mon、tm_mday 等。
- `strftime` 用于格式化时间为字符串，`strptime` 用于解析字符串为 struct_time。
- `perf_counter`、`monotonic`、`process_time` 适合做性能测试和计时。
- `sleep` 可用于定时、延时等场景。
- `ctime` 和 `asctime` 都能将时间对象转为可读字符串，区别在于参数类型。

---

**总结：**
- `time` 模块用于时间戳、格式化、延时、计时等操作。
- 推荐用 `strftime`/`strptime` 进行时间字符串与 struct_time 互转。
- 计时推荐用 `perf_counter()` 或 `monotonic()`，延时用 `sleep()`。
- 详细 API 可查阅官方文档：https://docs.python.org/3/library/time.html

---



## 19. logging 模块常用属性和 API 总结

`logging` 模块是 Python 标准库中用于灵活记录日志的模块，支持多级别日志、格式化、文件/控制台输出、日志轮转等，适合生产环境和调试。

---

#### 一、常用日志级别

- `logging.DEBUG`：调试信息，最低级别
- `logging.INFO`：普通信息
- `logging.WARNING`：警告信息
- `logging.ERROR`：错误信息
- `logging.CRITICAL`：严重错误

---

#### 二、常用 API

- `logging.basicConfig(**kwargs)`：一次性配置日志系统（如日志级别、格式、输出位置等）
    - 常用参数：`level`、`filename`、`filemode`、`format`、`datefmt`
- `logging.getLogger(name=None)`：获取（创建）日志记录器对象
- `logging.debug(msg, *args, **kwargs)`：输出 DEBUG 级别日志
- `logging.info(msg, *args, **kwargs)`：输出 INFO 级别日志
- `logging.warning(msg, *args, **kwargs)`：输出 WARNING 级别日志
- `logging.error(msg, *args, **kwargs)`：输出 ERROR 级别日志
- `logging.critical(msg, *args, **kwargs)`：输出 CRITICAL 级别日志
- `logging.exception(msg, *args, **kwargs)`：输出 ERROR 级别日志并附带异常堆栈（常在 except 块中用）
- `logging.log(level, msg, *args, **kwargs)`：按指定级别输出日志

---

#### 三、Logger 对象常用方法

- `logger.setLevel(level)`：设置日志级别
- `logger.addHandler(handler)`：添加日志处理器（如文件、控制台等）
- `logger.removeHandler(handler)`：移除处理器
- `logger.handlers`：当前所有处理器列表
- `logger.propagate`：是否向父 logger 传递日志（默认 True）

---

#### 四、Handler 常用类型

- `logging.StreamHandler`：输出到控制台
- `logging.FileHandler`：输出到文件
- `logging.handlers.RotatingFileHandler`：支持日志文件轮转
- `logging.handlers.TimedRotatingFileHandler`：按时间轮转日志文件

---

#### 五、Formatter

- `logging.Formatter(fmt=None, datefmt=None)`：定义日志输出格式

---

#### 六、常用示例（详细版）

```python
import logging

# 1. 基础配置：输出到控制台，设置日志级别、格式和时间格式
logging.basicConfig(
    level=logging.INFO,  # 设置日志级别为 INFO
    format="%(asctime)s %(levelname)s %(filename)s:%(lineno)d %(message)s",  # 日志格式
    datefmt="%Y-%m-%d %H:%M:%S"  # 时间格式
)

logging.debug("调试信息（不会显示，因为级别为INFO）")
logging.info("普通信息")
logging.warning("警告信息")
logging.error("错误信息")
logging.critical("严重错误")

# 2. 输出日志到文件（覆盖写入，级别为 WARNING 及以上）
logging.basicConfig(
    filename="app.log",
    filemode="w",  # 覆盖写入，"a"为追加
    level=logging.WARNING,
    format="%(asctime)s %(levelname)s %(message)s"
)
logging.warning("这条会写入 app.log 文件")
logging.error("错误日志也会写入文件")

# 3. 高级用法：自定义 logger、handler、formatter
logger = logging.getLogger("mylogger")  # 创建/获取名为 mylogger 的 logger
logger.setLevel(logging.INFO)  # 设置日志级别

# 创建文件处理器，日志写入 my.log 文件
file_handler = logging.FileHandler("my.log", encoding="utf-8")
# 创建控制台处理器
console_handler = logging.StreamHandler()

# 定义日志输出格式
formatter = logging.Formatter(
    "%(asctime)s %(levelname)s [%(name)s] %(filename)s:%(lineno)d %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# 添加处理器到 logger
logger.addHandler(file_handler)
logger.addHandler(console_handler)

# 输出日志（同时到文件和控制台）
logger.info("自定义日志 - info")
logger.error("自定义日志 - error")

# 4. 日志轮转（按文件大小轮转）
from logging.handlers import RotatingFileHandler

rotating_handler = RotatingFileHandler(
    "rotate.log", maxBytes=1024, backupCount=3, encoding="utf-8"
)
rotating_handler.setFormatter(formatter)
logger.addHandler(rotating_handler)
logger.warning("这条日志会写入轮转日志文件")

# 5. 异常日志记录
try:
    1 / 0
except Exception as e:
    logger.exception("捕获到异常：")
```

**说明：**
- `basicConfig` 只能调用一次，多次调用只生效第一次。
- 推荐复杂场景用自定义 logger、handler、formatter 组合，灵活输出到多个目标。
- `logger.exception()` 会自动记录异常堆栈信息，常用于 except 块中。
- `RotatingFileHandler` 支持日志文件按大小轮转，`TimedRotatingFileHandler` 支持按时间轮转。
- 日志格式常用变量：`%(asctime)s` 时间，`%(levelname)s` 级别，`%(filename)s` 文件名，`%(lineno)d` 行号，`%(message)s` 日志内容。

---

**总结：**
- `logging` 模块支持多级别、格式化、文件/控制台/轮转等多种日志输出方式。
- 推荐用 `basicConfig` 快速配置，复杂场景用 logger/handler/formatter 组合。
- 详细 API 可查阅官方文档：https://docs.python.org/3/library/logging.html



## 20. random 模块常用属性和 API 总结

`random` 模块是 Python 标准库中用于生成伪随机数、随机选择、打乱序列、采样等操作的模块，常用于数据模拟、抽样、洗牌、验证码等场景。

---

### 一、常用 API

- `random.random()`：返回 [0.0, 1.0) 区间的随机浮点数。
- `random.uniform(a, b)`：返回 [a, b] 区间的随机浮点数（a、b 顺序无关）。
- `random.randint(a, b)`：返回 [a, b] 区间的随机整数（包含 a 和 b）。
- `random.randrange(start, stop[, step])`：返回指定范围内按步长的随机整数（不包含 stop）。
- `random.choice(seq)`：从非空序列中随机返回一个元素。
- `random.choices(population, weights=None, k=1)`：可加权随机选取 k 个元素（可重复）。
- `random.sample(population, k)`：从总体中随机采样 k 个不重复元素。
- `random.shuffle(seq)`：原地打乱序列顺序（只适用于可变序列，如 list）。
- `random.seed(a=None)`：初始化随机数种子，保证结果可复现。
- `random.getstate()` / `random.setstate(state)`：获取/设置随机数生成器的内部状态。
- `random.betavariate(alpha, beta)`、`random.expovariate(lambd)`、`random.gauss(mu, sigma)`、`random.normalvariate(mu, sigma)`、`random.lognormvariate(mu, sigma)`、`random.paretovariate(alpha)`、`random.triangular(low, high, mode)`、`random.vonmisesvariate(mu, kappa)`、`random.gammavariate(alpha, beta)`、`random.weibullvariate(alpha, beta)`：各种常见概率分布的随机数生成。

---

### 二、常用示例

```python
import random

# 1. 基本随机数
print("0~1随机浮点数 random.random()：", random.random())
print("1~10随机浮点数 random.uniform(1, 10)：", random.uniform(1, 10))
print("1~10随机整数 random.randint(1, 10)：", random.randint(1, 10))
print("0~9（步长2）随机整数 random.randrange(0, 10, 2)：", random.randrange(0, 10, 2))

# 2. 序列操作
lst = ['a', 'b', 'c', 'd']
print("随机选一个元素 random.choice(lst)：", random.choice(lst))
print("随机选两个元素（可重复）random.choices(lst, k=2)：", random.choices(lst, k=2))
print("随机采样两个元素（不重复）random.sample(lst, 2)：", random.sample(lst, 2))
random.shuffle(lst)
print("打乱后的列表 random.shuffle(lst)：", lst)

# 3. 随机种子
random.seed(42)
print("固定种子后 random.random()：", random.random())

# 4. 常见分布
print("正态分布随机数 random.gauss(0, 1)：", random.gauss(0, 1))
print("指数分布随机数 random.expovariate(1)：", random.expovariate(1))
print("beta分布随机数 random.betavariate(0.5, 0.5)：", random.betavariate(0.5, 0.5))

# 5. 获取/设置状态
state = random.getstate()
print("保存状态后 random.randint(1, 100)：", random.randint(1, 100))
random.setstate(state)
print("恢复状态后 random.randint(1, 100)：", random.randint(1, 100))
```

---

### 三、常见应用场景

- 随机抽奖、验证码、洗牌、采样、数据增强、模拟实验、游戏开发等。

---

### 四、注意事项

- `random` 生成的是伪随机数，适合一般用途，不适合加密场景（加密用 `secrets` 模块）。
- `random.shuffle()` 只能用于可变序列（如 list），不可用于元组、字符串。
- 设置相同的 `seed` 可复现随机序列，便于调试和测试。

---

**总结：**
- `random` 模块提供丰富的随机数生成和序列操作工具，适合绝大多数日常开发场景。
- 推荐掌握 `random.random()`、`randint()`、`choice()`、`sample()`、`shuffle()`、`seed()` 等常用方法。
- 详细 API 可查阅官方文档：https://docs.python.org/3/library/random.html


