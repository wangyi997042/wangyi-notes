结合简历亮点（6年经验、架构优化/低代码/微前端/跨端实战、性能优化成果）和招聘核心要求（架构设计、基建建设、流程改进、多端性能优化、新技术探索），设计以下**针对性强、挖掘实际能力**的面试题，覆盖技术深度、项目落地、团队协作三大维度：

### 一、 架构设计与前端基建（紧扣招聘职责1、2、5）
1. 你在众安科技主导搭建了私有源并制定发包规范，能否详细说说私有源的技术选型（比如Verdaccio/Nexus）、发包流程的设计逻辑，以及如何解决多团队协作中“包版本冲突、依赖冗余”的问题？
答：在众安科技搭建私有源时，技术选型用了Verdaccio——轻量、易部署，适合团队内部10+人协作场景，无需复杂运维成本。发包流程设计了三层管控：一是提交规范，要求遵循Angular Commit Message规范（feat/fix/docs等前缀），配合husky做提交校验；二是版本管理，强制语义化版本（Major.Minor.Patch），避免“随意升版”导致依赖冲突；三是审核机制，npm包发布前需通过CI自动构建测试，再由技术负责人Code Review后手动触发发布。解决多团队依赖问题的核心是两点：① 用pnpm的workspace管理monorepo项目，统一维护依赖版本，生成lockfile确保环境一致；② 搭建私有源镜像同步npm官方包，本地包优先从私有源拉取，避免冗余依赖，同时通过“包权限管控”限制非必要人员发包，减少垃圾包占用。

2. 你自研了20+通用组件库和低代码渲染引擎，支撑80%业务页面快速搭建——请问组件库的设计原则是什么（比如扩展性、兼容性）？低代码引擎如何平衡“通用化配置”和“保险行业个性化业务需求”？后续如何迭代维护组件库和引擎？
答：组件库的设计原则核心是“原子化+可扩展+多端兼容”：原子化拆分基础组件（按钮、输入框等），再组合成业务组件（保单卡片、表单组），同时预留自定义插槽和Props，支持样式覆盖；多端兼容则依托uni-app和React的跨端能力，确保组件在H5/小程序/App中表现一致。平衡通用化和保险行业个性化的关键是“配置化+钩子扩展”：通用页面（如登录、列表查询）直接通过JSON配置生成，个性化需求（如不同保司的保单展示规则）通过自定义钩子（Hooks/生命周期函数）嵌入业务逻辑，既不破坏通用架构，又能灵活适配。维护迭代方面，我们建立了“版本管理+反馈闭环”：组件库按语义化版本迭代，重大变更提前预告；同时搭建内部反馈平台，业务方遇到兼容性或功能缺失问题可直接提交，每月迭代1-2个小版本，同步更新技术文档和示例工程，降低团队上手成本。

3. 方舟统一接入平台是基于qiankun的微前端项目，你主导了5个子应用接入和权限管控——请说明多子应用统一登录的实现方案（比如JWT令牌的流转、跨应用状态共享），以及解决了哪些微前端常见痛点（如样式隔离、子应用加载性能、跨应用通信）？
答：方舟统一接入平台的统一登录方案是“JWT+全局状态共享”：用户在主应用登录页完成身份验证后，后端返回JWT令牌，主应用将令牌存储在localStorage（脱敏处理），并通过qiankun的`initGlobalState`将用户信息、权限列表同步给所有子应用；子应用初始化时读取全局状态，无需重复登录，接口请求时自动携带令牌。解决的微前端核心痛点：① 样式隔离：子应用启用shadow DOM，避免全局样式污染，同时主应用暴露统一设计 tokens，确保视觉一致性；② 加载性能：采用“预加载+按需加载”，主应用启动时预加载高频子应用的静态资源，非高频子应用触发时再加载，首屏加载速度提升30%；③ 跨应用通信：除了全局状态，还封装了自定义事件总线，支持子应用间复杂数据传递（如A应用的客户ID传递给B应用的详情页），通信延迟控制在50ms内。

4. 招聘要求负责“前端架构设计”，你同时有Vue3（电销外呼系统）和React（低代码引擎）的大型项目经验——请结合实际场景，分析这两个框架在架构设计上的核心差异，以及你在项目中选择框架的决策依据是什么？
答：两者核心差异集中在“状态管理、渲染机制、生态适配”：Vue的架构更偏向“开箱即用”，响应式系统（Vue3的Proxy）简化状态更新逻辑，组件化设计清晰，适合快速迭代的业务场景；React则更强调“灵活扩展”，Fiber架构支持渲染中断和优先级调度，Hooks便于复杂逻辑复用，更适合低代码、微前端这类需要深度定制的场景。我在项目中的选型依据主要看三点：① 业务复杂度：简单业务（如客户推荐系统）用Vue，开发效率更高；复杂状态管理和渲染优化场景（如低代码引擎）用React，生态更完善；② 团队熟悉度：众安科技团队以React为主，所以低代码、微前端项目优先选React；南天软件的电销外呼系统团队更熟悉Vue，就用Vue3；③ 生态需求：需要集成大量第三方工具（如rrweb、qiankun）时，React的生态适配性更强；多端适配（小程序/H5）时，Vue+uni-app的组合更成熟。


### 二、 流程改进与生产效率（紧扣招聘职责3）
1. 你自研了前端脚手架和wdmjs工具，落地了ESLint+Prettier+Sentry规范——请具体说说脚手架的核心功能模块（比如项目初始化、构建打包、环境配置），如何适配Vue/React不同技术栈的项目？这些工具如何直接提升开发、构建、发布的效率（比如构建速度提升多少、发布流程简化了哪些环节）？
答：自研的wdmjs脚手架核心模块包括四部分：① 项目初始化：提供Vue/React两种技术栈模板，支持自定义配置（是否集成TS、路由、状态管理）；② 构建打包：基于Webpack/Vite封装，内置Tree Shaking、Code Split优化，无需手动配置；③ 环境配置：支持开发/测试/生产多环境切换，通过.env文件管理环境变量；④ 部署脚本：集成CI/CD插件，一键打包并推送至测试/生产服务器，支持灰度发布。适配不同技术栈的关键是“插件化设计”：核心逻辑抽离为基础包，Vue和React的差异化配置（如loader、插件）做成独立插件，用户初始化时选择技术栈即可自动加载。效率提升很直观：构建速度较原生Webpack提升50%（大型项目从8分钟缩至4分钟）；发布流程从“本地打包→上传服务器→手动部署”的30分钟，缩短至10分钟（自动化部署）；新员工上手项目的时间从3天缩至1天（模板统一、配置内置）。

2. 低代码引擎让团队开发效率提升40%，请举例说明：一个新的保险产品H5页面（比如新保模块），通过你的低代码方案，从需求确认到上线的流程是什么？相比传统开发模式，具体节省了哪些环节的成本？
答：以新保模块（保险购买H5）为例，低代码开发流程是：① 需求确认：和产品、保司确认页面结构（如投保信息表单、保单预览、支付入口）和业务规则（如必填项校验、保费计算逻辑）；② 页面配置：业务人员通过可视化编辑器拖拽组件（如输入框、下拉框、按钮），配置组件属性（如占位符、校验规则）；③ 定制业务组件：通用组件满足不了的场景（如保费计算器、保司logo展示），开发专属业务组件接入组件库，通过配置化关联；④ JSON校验：编辑器自动进行JSON Schema校验，拦截不合规配置（如缺少必填属性、格式错误）；⑤ 预览上线：本地预览效果无误后，一键生成JSON配置文件，同步至后端，渲染引擎直接加载配置生成页面。相比传统开发，节省了“编写基础UI代码、手动配置路由、适配多端样式”三个核心环节，新保模块的开发周期从10天缩至3天，节省70%的开发成本，同时减少了80%的UI兼容性问题。

3. 你落地了Git Flow分支管理规范，在多团队并行开发微前端子应用时，如何通过分支策略避免代码冲突、保障版本稳定性？Code Review的重点是什么，如何推动团队养成规范协作习惯？
答：落地的Git Flow规范核心是“四分支模型”：master（生产环境分支，仅用于发布）、dev（开发分支，聚合feature分支）、feature（功能分支，从dev创建，完成后合并回dev）、hotfix（紧急修复分支，从master创建，修复后同步至master和dev）。多团队并行开发时，避免冲突的关键是“高频合并+规范提交”：要求feature分支每天至少合并1次dev的最新代码，用merge --no-ff保留合并记录；提交信息必须遵循规范，便于追溯。Code Review的重点包括：① 代码规范（是否符合ESLint/Prettier规则）；② 逻辑合理性（业务规则是否准确，边界情况是否处理）；③ 性能问题（是否有冗余渲染、无效请求）；④ 安全性（敏感数据是否脱敏，权限控制是否到位）。推动团队养成习惯的方法是：① 新人培训时重点讲解规范，提供示例代码；② 用自动化工具（如GitLab的MR模板）强制触发Code Review，至少1名资深工程师通过后才能合并；③ 每月分享Code Review中的典型问题，形成团队共识。

### 三、 多端性能优化与跨端适配（紧扣招聘职责4）
1. 你将小程序包体积从2MB压缩至1.2MB，首屏提速30%+——请详细说明压缩包体积的具体技术手段（比如分包加载、Tree Shaking、资源压缩），以及跨端（H5/小程序/App）性能指标的搜集方案（比如用什么工具采集LCP、启动速度），如何根据数据分析优化方向？
答：小程序包体积从2MB压缩至1.2MB的核心手段有四个：① 分包加载：将非首页的功能（如我的保单、帮助中心）拆分为分包，按需加载，主包体积控制在1MB内；② Tree Shaking：剔除无用代码（如第三方库中未使用的组件、工具函数），仅保留核心逻辑；③ 资源压缩：图片转WebP格式，压缩率达40%，JS/CSS文件通过Terser压缩，移除注释和空格；④ 第三方库按需引入：如Vant UI仅引入所需组件（如按钮、表单），而非全量引入，减少冗余代码。性能指标搜集方案分两类：① 基础指标：用微信开发者工具的性能面板采集启动时间、首屏加载时间、LCP（最大内容绘制）；② 自定义指标：通过自研埋点SDK采集页面切换速度、接口响应时间、组件渲染耗时，上报至后台形成数据看板。数据分析时优先聚焦“核心路径指标”（如登录页加载时间、投保流程响应速度），通过筛选“指标异常样本”（如加载时间＞3秒的用户），定位瓶颈（比如某张未压缩的大图、冗余的接口请求），再针对性优化。

2. 智能物流系统需支持500+车辆实时轨迹追踪，你优化了高德地图渲染性能——请问地图渲染的核心性能瓶颈是什么？你采用了哪些优化手段（比如瓦片加载、轨迹缓存、虚拟滚动）？如何确保高并发下轨迹追踪的延迟控制在合理范围？
答：500+车辆轨迹追踪的核心瓶颈是“DOM节点过多导致的频繁重绘、数据推送频繁导致的性能占用”。优化手段包括：① 瓦片加载策略：设置地图缩放级别阈值，低缩放时不渲染单个车辆标记，仅显示聚合点；高缩放时才渲染具体车辆，减少DOM节点数量；② 轨迹缓存：车辆轨迹数据按时间段缓存，避免重复请求，同时采用“增量更新”，仅推送位置变化的车辆数据，而非全量数据；③ 虚拟滚动思想：只渲染地图可视区域内的车辆标记，超出区域的标记自动销毁，减少内存占用；④ 渲染节流：车辆位置更新时，用requestAnimationFrame做节流，避免1秒内多次重绘，将帧率稳定在60fps。高并发下延迟控制的关键是“数据分批推送+WebSocket优化”：后端将500+车辆数据分10批推送（每批50条），避免单次推送数据量过大；WebSocket开启压缩（permessage-deflate），减少传输体积，同时优化心跳检测（30秒一次），避免连接频繁断开重连。

3. 嗨问系统支持微信/钉钉/自有App多容器适配，通过JSBridge调用原生功能——请举例说明你遇到的“不同容器下JSBridge兼容性问题”（比如钉钉和微信的API差异），以及对应的解决方案？如何保证多容器环境下的功能一致性和体验稳定性？
答：嗨问系统在微信/钉钉/自有App中遇到的核心兼容性问题是“JSBridge API命名差异+功能支持程度不同”：比如微信的分享功能是`wx.updateAppMessageShareData`，钉钉是`dd.biz.share`；自有App的部分原生功能（如文件上传）没有统一API，需要单独适配。解决方案是“封装适配层+降级处理”：① 抽象JSBridge工具类，内部判断当前容器类型（通过`navigator.userAgent`），对外暴露统一接口（如`bridge.share()`），用户调用时无需关注底层差异；② 对未支持的功能做降级，比如钉钉不支持某类分享样式，就默认使用基础分享样式；自有App没有文件上传API，就降级为H5原生上传；③ 建立兼容性测试矩阵，每次迭代前在三大容器的不同版本（如微信iOS/Android、钉钉最新版/旧版）中做回归测试，确保功能一致性。体验稳定性方面，还会监听JSBridge调用失败的异常，通过Sentry上报，及时修复未覆盖的兼容场景。

4. 你优化了SDK内存占用至5%，前端异常率下降75%——请说说SDK内存泄漏的排查过程（比如用什么工具、定位到哪些泄漏场景），以及Sentry在异常监控中的配置和使用逻辑，如何通过异常数据反推优化方向？
答：用户行为录制SDK的内存优化过程：首先用Chrome的Memory面板和Performance工具排查泄漏场景，发现主要问题是“rrweb录制时未及时清理DOM快照引用、事件监听未移除”。优化手段包括：① 手动解绑事件：录制停止后，销毁rrweb的录制实例，移除所有事件监听；② 弱引用存储：用WeakMap存储DOM快照，避免强引用导致垃圾回收无法回收；③ 批量清理缓存：设置缓存上限（如最多保留30分钟的录制数据），超过上限自动清理旧数据；④ 采样录制：非核心业务页面降低录制采样率（如每2秒录制一次），减少性能开销，最终将内存占用从原来的20%降至5%。Sentry的配置逻辑是：① 捕获范围包括JS错误、接口请求错误、资源加载错误，同时自定义捕获SDK录制异常；② 采样率设置为100%（核心业务），避免遗漏关键错误；③ 按错误级别（info/warn/error）设置告警，error级错误实时推送至团队钉钉群；④ 通过异常数据反推优化方向，比如某类DOM节点泄漏错误频繁出现，就针对性检查对应的组件卸载逻辑，最终让前端异常率下降75%。


### 四、 核心技术落地与难点突破（紧扣招聘职责1、5）
1. 电销外呼系统需支撑300+坐席并发，你用虚拟滚动优化了大数据列表渲染——请说明虚拟滚动的实现原理（比如可视区域计算、DOM复用），如何处理“坐席快速切换列表、搜索筛选”等高频操作下的性能稳定性？权限体系的设计逻辑是什么，如何满足等保三级合规要求？
答：电销外呼系统的虚拟滚动实现原理是“可视区域计算+DOM复用”：① 先获取列表容器高度和单条数据的行高，计算出可视区域能显示的条目数量（如容器高500px，行高50px，可显示10条）；② 只渲染当前可视区域的10条DOM节点，上下各预留2条缓冲节点；③ 监听滚动事件，计算滚动偏移量，动态更新可视区域的数据源和DOM位置，同时复用已创建的DOM节点，避免频繁创建销毁。高频操作（如坐席快速切换列表、搜索筛选）的性能保障：① 搜索筛选时先防抖（300ms），避免频繁触发渲染；② 列表数据做缓存，切换回已浏览的列表时直接复用数据，无需重新计算；③ 用requestAnimationFrame处理滚动更新，避免卡顿。权限体系设计采用RBAC模型：① 后端返回用户角色（如管理员、普通坐席）对应的权限列表（功能权限+数据权限）；② 前端基于权限列表动态生成路由（无权限的路由不注册），页面内通过自定义指令（如`v-permission`）控制按钮、菜单的显示隐藏；③ 接口请求时携带权限令牌，后端校验数据访问权限（如普通坐席只能查看自己的客户数据），最终满足等保三级合规要求（数据加密传输、访问日志审计、权限最小化）。

2. 通用型用户行为录制SDK基于rrweb开发，准确率99%且支持数据脱敏——请说说数据脱敏的具体方案（比如敏感字段替换、加密），如何平衡“录制精度”和“性能开销”（比如避免录制大量无意义操作导致的内存占用）？SDK打包为npm包发布至私有源后，如何支持多项目快速集成和版本迭代？
答：数据脱敏的核心方案是“规则配置+正则匹配”：① 预设敏感字段规则（如手机号、身份证号、银行卡号），通过正则表达式匹配录制内容中的敏感信息；② 处理方式分两种：手机号/身份证号用“****”替换中间部分，银行卡号只保留后4位；③ 支持自定义脱敏规则，不同业务场景（如新保/续保）可配置不同的敏感字段，避免过度脱敏影响问题排查。平衡录制精度和性能的关键是“按需录制”：① 允许业务方配置录制范围（如仅录制表单页面，不录制支付页面）；② 对大文件上传、视频播放等场景自动暂停录制，避免占用过多带宽和内存；③ 录制数据采用二进制格式压缩后通过WebSocket上报，减少传输压力。多项目集成方面，SDK打包为umd格式，支持script标签引入和npm安装两种方式，同时提供详细的集成文档和示例代码；版本迭代时遵循语义化版本，兼容旧版本配置，确保已集成项目无需修改代码即可升级。

3. 你精通WebSocket实时通信（延迟＜200ms），在电销外呼系统和嗨问系统中都有应用——请说明WebSocket连接的稳定性保障方案（比如重连机制、心跳检测），如何处理“网络波动、多终端登录”导致的通信异常？
答：电销外呼系统和嗨问系统的WebSocket稳定性保障方案包括：① 重连机制：客户端定时发送心跳包（10秒一次），若3次未收到服务器响应，则触发重连，重连时采用指数退避策略（1秒、3秒、5秒），避免频繁请求；② 消息队列：网络波动时，未发送成功的消息存入本地队列，重连成功后批量发送，确保消息不丢失；③ 多终端登录处理：用户同时登录PC端和移动端时，服务器通过令牌校验唯一登录状态，新终端登录时踢下线旧终端，避免消息重复接收；④ 通信降级：WebSocket连接失败时，自动降级为HTTP长轮询，确保核心功能（如通话状态同步、问答消息）正常使用，待网络恢复后自动切换回WebSocket，延迟控制在200ms内。

4. 招聘要求“参与新技术探索、推进系统架构演化”，你最近在前端领域关注哪些新技术？是否有计划将其应用到现有架构中（比如React Server Components、Vue的Vite优化）？请举例说明你之前推动技术升级的经历（比如从Vue2迁移到Vue3、引入微前端），如何制定计划和规避风险？
答：最近重点关注的新技术是React Server Components（RSC）和Vite：RSC能将组件渲染逻辑放在服务端，减少客户端JS体积，适合解决低代码引擎首屏加载慢的问题；Vite的按需编译和热更新特性，能替代Webpack提升开发和构建效率。之前推动技术升级的案例是“Vue2项目迁移至Vue3”：首先成立专项小组，调研Vue3的核心特性（Composition API、Proxy响应式）和迁移风险（如过滤器废弃、生命周期变更）；然后选择“嗨问系统”的一个非核心模块做试点迁移，验证兼容性和性能提升；接着编写迁移手册，组织团队培训，重点讲解Composition API的逻辑复用方式；最后分阶段全量迁移，同时保留Vue2的兼容层（如@vue/compat），避免线上问题，最终实现组件复用率提升40%，构建速度提升30%。架构演化的核心驱动力是“业务需求+技术痛点”：比如业务迭代频繁就引入低代码，多系统分散就用微前端，性能瓶颈就做全链路优化，始终让技术服务于业务。

### 五、 团队协作与软实力（紧扣招聘要求4、团队管理优先）
1. 你在众安科技负责前端管理工作，制定了低代码开发规范和发包规范——当团队成员对规范有异议（比如觉得约束过多、不适应低代码模式）时，你如何沟通并推动规范落地？如何评估规范落地后的效果（比如代码质量提升、冲突减少）？
答：推动低代码开发规范时，部分团队成员觉得“配置化限制灵活性，复杂业务不好实现”。我的处理方式是：① 先倾听具体诉求，比如有开发反馈“某保司的特殊表单校验规则无法通过配置实现”；② 调整规范灵活性，在原有配置化基础上增加“自定义脚本”入口，支持编写简单JS逻辑满足特殊需求；③ 用试点项目验证效果，比如让提出异议的开发用低代码实现该保司的表单页面，实际体验到“基础配置+少量自定义”的效率提升后，异议自然消除。评估规范落地效果的核心是“数据化”：比如代码冲突率从每月15次降至6次，新功能开发周期平均缩短40%，前端异常率从8%降至2%，这些数据能直观体现规范的价值，也让团队认可后续的优化方向。

2. 你在项目中需要和安卓团队（智能物流系统）、后端团队（NodeJS接口联调）协作——请举例说明一次跨团队协作中遇到的技术分歧（比如原生功能调用、接口设计），你是如何沟通解决的？
答：智能物流系统和安卓团队协作时，曾因“地图渲染性能”产生分歧：安卓团队认为是前端频繁调用地图API导致原生端卡顿，前端团队认为是原生地图SDK的渲染效率问题。解决步骤：① 共同搭建性能测试环境，用Android Profiler和前端Performance工具同时采集数据，发现核心瓶颈是“前端每秒推送500+车辆位置，原生端无法及时渲染”；② 一起制定优化方案：前端将位置推送频率从1秒/次降至2秒/次，同时批量推送变更数据；安卓团队优化地图渲染缓存，减少重复绘制；③ 分阶段测试验证，先在测试环境验证性能提升（卡顿次数从每秒3次降至0次），再灰度发布到生产环境，确保无线上问题。核心原则是“聚焦问题，而非立场”，跨团队协作的关键是建立共同目标（如“提升地图渲染流畅度”），通过数据说话，避免主观争论。

3. 招聘要求“有业务sense”，你长期做保险行业相关项目（新保/续保、电销外呼）——请说说你如何将前端技术方案与保险业务场景结合（比如通过数据可视化提升调度效率、通过低代码快速响应保险产品迭代）？如何平衡“技术优化的深度”和“业务上线的时效性”？
答：长期做保险行业前端，我会主动了解核心业务逻辑，比如“新保/续保的流程差异”“电销外呼的合规要求”“物流调度的核心指标”，让技术方案更贴合业务场景。比如电销外呼系统，除了实现基础的客户管理、通话控制，还结合“坐席绩效考核”业务，开发了实时通话数据看板（如接通率、通话时长），帮助运营团队优化调度策略；智能物流系统则针对“车辆调度效率”业务痛点，开发了多维度数据可视化（如车辆分布、运输时长），让调度员快速决策。平衡技术优化和业务时效性的原则是“核心功能优先上线，技术优化分阶段进行”：比如新保模块的核心需求是“支持3家保司的投保流程”，先实现基础功能保障上线，后续再通过低代码引擎优化配置效率、压缩包体积，既不影响业务上线时间，又能逐步提升技术架构的合理性。

4. 你提到“组件复用率提升40%、异常率下降75%”等成果，请问这些数据是如何量化统计的？在推动技术优化时，如何向团队和领导传递“技术价值”（比如业务效率提升、成本降低）？
答：量化数据的统计方式主要有三种：① 性能数据：通过前端监控工具（如Lighthouse、自研埋点）采集首屏时间、加载性能、内存占用；② 效率数据：通过项目管理工具（如Jira）统计开发周期，对比优化前后的耗时；③ 质量数据：通过Sentry统计异常率，Git统计代码冲突次数。比如“组件复用率提升40%”，是通过统计优化前后“重复编写的UI代码行数”得出；“首屏提速30%”是对比优化前后的LCP均值（从3秒降至2.1秒）。向团队和领导传递技术价值时，会将技术指标转化为业务价值：比如“首屏提速30%”对应“用户留存率提升8%”（基于行业数据），“开发效率提升40%”对应“每月节省10人天的开发成本，可支撑2个新增保司的业务需求”，让非技术人员也能理解技术优化的意义。

### 六、 补充深挖（针对简历亮点与招聘加分项）
1. 你有Node.js/Koa开发RESTful接口和中间件的经验，请问这些中间件的应用场景是什么（比如接口代理、权限校验、日志记录）？如何保证Node.js服务的高可用和性能？
答：用Node.js/Koa开发的中间件主要应用在三个场景：① 接口代理：前端项目调用后端接口时，通过中间件转发请求，解决跨域问题，同时统一添加请求头（如权限令牌、日志ID）；② 权限校验：中间件拦截接口请求，验证用户令牌的有效性，无权限则直接返回403，避免无效请求到达后端；③ 日志记录：记录接口的请求参数、响应结果、耗时，便于问题排查和性能分析。保障Node.js服务高可用的方案：① 集群部署：用PM2启动多个进程，利用CPU多核资源，避免单进程瓶颈；② 错误捕获：全局捕获未处理的Promise拒绝和异常，返回友好提示，同时记录错误日志；③ 监控告警：接入Prometheus+Grafana监控服务的CPU、内存、接口耗时，设置阈值告警（如接口耗时＞500ms触发告警）；④ 限流保护：用koa-ratelimit限制单IP的请求频率，避免恶意请求压垮服务。

2. 招聘要求熟悉微信/支付宝小程序开发，你用uni-app做了客户推荐系统——支付宝小程序和微信小程序在适配时，有哪些核心差异需要处理？如何优化支付宝小程序的加载性能和兼容性？
答：支付宝小程序和微信小程序的核心适配差异：① API前缀不同（微信是wx.xxx，支付宝是my.xxx）；② 组件兼容性差异（如支付宝的scroll-view不支持某些事件，微信的picker组件样式不同）；③ 包体积限制更严格（支付宝小程序主包体积上限1.5MB，微信是2MB）。优化方案：① 基于uni-app的条件编译，针对支付宝小程序单独处理API和组件，比如`#ifdef MP-ALIPAY`引入支付宝原生组件；② 资源压缩进一步优化，图片采用WebP格式且压缩至更小尺寸，第三方库优先选择支付宝生态支持更好的版本；③ 分包策略调整，将支付宝小程序的主包体积严格控制在1.2MB内，非核心功能全部放入分包；④ 适配支付宝的特有功能（如生活号跳转、芝麻信用授权），提升用户体验，最终实现支付宝小程序的加载速度较微信小程序仅慢10%，满足业务需求。

3. 你的个人技术博客或GitHub项目中，是否有沉淀过你提到的“低代码引擎、组件库、性能优化方案”相关的技术内容？如果有，能否分享一个你最深入钻研的技术点？
答：虽然没有公开的GitHub项目，但在公司内部沉淀了三类技术资产：① 低代码组件库和渲染引擎的技术文档（含核心原理、使用示例、常见问题）；② 前端工程化手册（脚手架使用、发包规范、Git Flow流程）；③ 性能优化案例集（内存泄漏、包体积压缩、地图渲染等场景的解决方案）。最深入钻研的技术点是“低代码渲染引擎的JSON Schema解析与DOM生成逻辑”：核心难点是“如何让JSON配置支持复杂业务逻辑（如条件渲染、数据联动）”，最终通过“JSON Schema扩展关键字（如if/then/else控制条件渲染，dependencies控制数据联动）+ 自定义渲染函数”解决；同时攻克了“跨层级数据流转”问题，设计了基于发布-订阅模式的自定义事件总线，让嵌套组件间的数据流无需通过props层层传递，提升了配置灵活性和渲染效率，该方案支撑了80%的保险业务页面快速搭建，团队开发效率提升40%。