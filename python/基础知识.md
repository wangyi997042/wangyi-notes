# Python 零基础必备知识总结

## 1. Python 简介
- Python 是一种高级、通用、解释型编程语言，语法简洁，易学易用，适合初学者。
- 广泛应用于数据分析、人工智能、Web开发、自动化、科学计算等领域。

---

## 2. 基础语法

### 2.1 注释
- 单行注释：`# 注释内容`
- 多行注释：三引号 `''' 注释内容 '''` 或 `""" 注释内容 """`

### 2.2 缩进
- Python 用缩进表示代码块（通常为4个空格），不能用大括号。

### 2.3 变量
- 变量无需声明类型，直接赋值即可。
```python
a = 10
name = "Tom"
```
### 2.4 格式化占位符总结

Python 支持多种字符串格式化方式，常用的格式化占位符有以下几种：

### 2.5 百分号 `%` 格式化（老式写法）

- `%s`：字符串
- `%d`：整数
- `%f`：浮点数（可指定精度，如 `%.2f` 表示保留两位小数）

**示例：**
```python
name = "Tom"
age = 18
score = 95.678
print("姓名：%s, 年龄：%d, 分数：%.2f" % (name, age, score))
# 输出：姓名：Tom, 年龄：18, 分数：95.68
```

---

#### 2.6 `str.format()` 方法

- 使用 `{}` 作为占位符，可以按顺序、索引或关键字填充。

**示例：**
```python
print("姓名：{}, 年龄：{}, 分数：{:.1f}".format(name, age, score))
print("姓名：{0}, 年龄：{1}, 分数：{2:.1f}".format(name, age, score))
print("姓名：{n}, 年龄：{a}, 分数：{s:.1f}".format(n=name, a=age, s=score))
```

---

#### 2.7 f-string（格式化字符串字面量，Python 3.6+ 推荐）

- 在字符串前加 `f`，直接在 `{}` 内写变量或表达式。

**示例：**
```python
print(f"姓名：{name}, 年龄：{age}, 分数：{score:.2f}")
```

---

#### 2.8 常见格式化控制

- `{:.2f}`：保留两位小数
- `{:>5}`：右对齐，占 5 个字符宽度
- `{:<5}`：左对齐，占 5 个字符宽度
- `{:0>3}`：不足 3 位用 0 补齐

**示例：**
```python
num = 7
print(f"{num:0>3}")  # 007
print(f"{num:<5}")   # 7    
```

---

**总结**：  
- 推荐使用 f-string，语法简洁、效率高。
- 了解 `%` 和 `str.format()` 便于阅读和维护老代码。
---

## 3. 数据类型与常用方法

### 3.1 数字类型
- `int`（整数）、`float`（浮点数）、`complex`（复数）
常用属性/方法：
bit_length()（int）：获取整数的二进制位数
is_integer()（float）：判断浮点数是否为整数
real、imag（complex）：获取实部和虚部
conjugate()（complex）：共轭复数

```python
a = 5
b = 3.14
c = 2 + 3j
```

### 3.2 字符串（str）
- 字符串不可变，支持切片、拼接、查找等操作。
常用方法：
upper()、lower()：大小写转换
capitalize(): 首字母变为大写
replace()：替换
find()、index()：查找
split()、join()：分割与拼接
strip()：去除首尾空白
startswith()、endswith()：判断前缀/后缀

```python
s = "hello"
print(s.upper())      # 转大写
print(s.lower())      # 转小写

print(s[:4])         # 切片 hell
print(s[1:])         # 切片 ello
print(s[1:4])         # 切片 
print(s.replace("l", "x"))  # 替换
print(s.find("e"))    # 查找
print(s.split('e'))   # 分割  ['h', 'llo']
print(s.join('ab'))   # 分割  ahellob
print(s.startswith('he'))   # 分割  True

print(len(s))         # 长度
```
### 3.2.1 切片的常用操作

切片（slice）是 Python 中用于截取序列（如字符串、列表、元组）部分元素的操作，语法为 `序列[起始:结束:步长]`。

#### 1. 基本切片
```python
lst = [0, 1, 2, 3, 4, 5]
print(lst[1:4])    # [1, 2, 3]，从下标1到下标3（不含4）
print(lst[:3])     # [0, 1, 2]，从头到下标2
print(lst[2:])     # [2, 3, 4, 5]，从下标2到结尾
```

#### 2. 步长切片
```python
print(lst[::2])    # [0, 2, 4]，每隔一个取一个
print(lst[1:5:2])  # [1, 3]，从下标1到4，每隔一个取一个
```

#### 3. 反向切片
```python
print(lst[::-1])   # [5, 4, 3, 2, 1, 0]，倒序
print(lst[-3:-1])  # [3, 4]，倒数第3到倒数第2（不含-1）
```

#### 4. 字符串切片
```python
s = "abcdefg"
print(s[:4])       # 'abcd'
print(s[2:5])      # 'cde'
print(s[::-1])     # 'gfedcba'
```

#### 5. 切片赋值（仅列表支持）
```python
lst[1:3] = [10, 11]
print(lst)         # [0, 10, 11, 3, 4, 5]
```

---

**总结：**
- 切片不包含结束下标对应的元素。
- 步长可为负，实现反向切片。
- 字符串、列表、元组都支持切片操作。
# 字符串编码与解码示例

# 编码：str -> bytes
```python
s = "你好，Python"
b = s.encode("utf-8")
print(b)  # 输出: b'\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8cPython'
```

# 3.2.2 解码：bytes -> str
```python
s2 = b.decode("utf-8")
print(s2)  # 输出: 你好，Python
```
# 3.2.3 指定错误处理方式

```python
s3 = "hello世界"
b2 = s3.encode("ascii", errors="ignore")
print(b2)  # 输出: b'hello'
b3 = s3.encode("ascii", errors="replace")
print(b3)  # 输出: b'hello??'
```

### 3.3 列表（list）
- 可变序列，支持增删改查。
常用方法：
append()：追加
insert()：插入
remove()、pop()：删除
index()：查找
sort()、reverse()：排序与反转
extend()：合并列表

```python
lst = [1, 2, 3]
str = 'hello'
print(str[-1])        # o
lst.append(4)         # 追加
lst.insert(1, 9)      # 插入
lst.remove(2)         # 删除指定元素 [1, 3]
lst.pop()             # 用下标删除，默认删除最后一个
lst[0] = 10           # 修改
print(lst[1])         # 访问
print(len(lst))       # 长度
print(lst.index(3))   # 查找
lst.sort()            # 排序
lst.reverse()         # 反转
lst.extend([4, 5, 6]) # 合并列表 [1, 2, 3, 4, 5, 6]

```

### 3.4 元组（tuple）
- 不可变序列，常用于不可更改的数据。
常用方法：
count()：统计元素出现次数
index()：查找元素位置

```python
t = (1, 2, 3)
tup = (1,)
print(t[0])
print(len(t))
print(t.count(2))     # 统计出现次数
print(t.index(3))     # 查找
print(type(tup))      # 只有一个元素必须要加逗号
```

### 3.5 字典（dict）
- 键值对集合，支持快速查找。
常用方法：
keys()、values()、items()：获取键、值、键值对
get()：安全获取值
pop()、popitem()：删除元素
clear(): 清空
update()：更新字典
setdefault()：获取或设置默认值

```python
d = {"name": "Tom", "age": 18}
print(d["name"])
d["age"] = 20         # 修改
d["gender"] = "男"    # 新增
d.pop("name")         # 删除
d.popitem()           # 删除最后一个
print(d.keys())       # 所有键
print(d.values())     # 所有值
print(d.items())      # 所有键值对
d.update({"age": 23}) # 更新字典
d.setdefault("sex", "男") # 获取或设置默认值
print("age" in d)     # 判断键是否存在
```

### 3.6 集合（set）
- 无序不重复元素集合，常用于去重和集合运算。
常用方法：
add()、remove()、discard()：添加/删除元素
union()、intersection()、difference()：并集、交集、差集
update()：批量添加

```python
s = {1, 2, 3, 2}
s.add(4)
s.remove(2)
s.discard(2)  # 移除元素2，s变为{1, 3}
print(len(s))
print(3 in s)
s2 = {3, 4, 5}
print(s.union(s2))    # 并集
print(s.intersection(s2))  # 交集
print(s.difference(s2))    # 差集
s.update([4, 5, 6]) # {1, 2, 3, 4, 5, 6}
```

---

## 4. 运算符
- 算术：`+ - * / // % **`
- 比较：`== != > < >= <=`
- 逻辑：`and or not`
- 成员：`in , not in`
- 赋值：`= += -= *= /=`

#### 4.1. 逻辑运算符（and, or, not）
```python
a = True
b = False

print(a and b)   # False，只有都为True才为True
print(a or b)    # True，只要有一个为True就为True
print(not a)     # False，取反
```

#### 4.2. 成员运算符（in, not in）
```python
lst = [1, 2, 3]
print(2 in lst)      # True，2在列表中
print(5 in lst)      # False，5不在列表中
print(4 not in lst)  # True，4不在列表中

s = "hello"
print("e" in s)      # True，'e'在字符串中
print("x" not in s)  # True，'x'不在字符串中

d = {"a": 1, "b": 2}
print("a" in d)      # True，'a'是字典的键
print(1 in d.values()) # True，1是字典的值
```

---

## 5. 条件与循环

### 5.1 条件语句
```python
if a > 0:
    print("正数")
elif a == 0:
    print("零")
else:
    print("负数")
```

### 5.2 循环语句
```python
for i in range(5):
    print(i)

lst = [1, 2, 3]
for item in lst:
    print(item)

i = 0
while i < 3:
    print(i)
    i += 1
```

### 5.3 循环控制
- `break` 跳出循环
- `continue` 跳过本次循环
- `pass` 占位，不做任何事

---

## 6. 函数

### 6.1 定义与调用
```python
def add(a, b):
    return a + b

print(add(2, 3))
```

### 6.2 参数类型
- 默认参数、可变参数（*args）、关键字参数（**kwargs）
```python
def func(a, b=2, *args, **kwargs):
    print(a, b, args, kwargs)
func(1, 3, 4, 5, x=6, y=7)
```

### 6.3 匿名函数
```python
f = lambda x, y: x + y
print(f(1, 2))
```

### 6.4 作用域
- 局部变量、全局变量，`global` 和 `nonlocal` 关键字

---

## 7. 常用内置函数
- `print()`、`len()`、`type()`、`range()`、`enumerate()`、`zip()`、`map()`、`filter()`、`sorted()`、`input()`、`sum()`、`max()`、`min()`、`abs()` 等

Python 提供了丰富的内置函数，无需导入即可直接使用。以下是常用内置函数的详细说明和示例：

### 7.1. 输出与输入
- `print(*objects, sep=' ', end='\n')`  
  打印输出内容到控制台。
  ```python
  print("Hello", "World", sep=", ", end="!\n")  # Hello, World!
  ```

- `input(prompt=None)`  
  从控制台读取用户输入，返回字符串类型。
  ```python
  name = input("请输入姓名：")
  print(name)
  ```

---

### 7.2. 类型与转换
- `type(obj)`  
  返回对象的类型。
  ```python
  print(type(123))  # <class 'int'>
  ```

- `int(x)`、`float(x)`、`str(x)`、`bool(x)`  
  类型转换。
  ```python
  print(int("12"))      # 12
  print(float("3.14"))  # 3.14
  print(str(100))       # "100"
  print(bool(0))        # False
  print(eval("10+10"))  # 20
  ```

- `list(iterable)`、`tuple(iterable)`、`set(iterable)`、`dict(mapping)`  
  容器类型转换。
  ```python
  print(list("abc"))  # ['a', 'b', 'c']
  print(tuple([1,2])) # (1, 2)
  print(set([1,2,2])) # {1, 2}
  print(dict([('a',1),('b',2)])) # {'a': 1, 'b': 2}
  ```

---

### 7.3. 数学与序列操作
- `len(s)`  
  返回对象长度。
  ```python
  print(len([1,2,3]))  # 3
  ```

- `sum(iterable, start=0)`  
  求和。
  ```python
  print(sum([1,2,3]))  # 6
  ```

- `max(iterable, *args, key=None)`、`min(iterable, *args, key=None)`  
  求最大/最小值。
  ```python
  print(max(1, 5, 3))  # 5
  print(min([2, 8, 1])) # 1
  ```

- `abs(x)`  
  绝对值。
  ```python
  print(abs(-7))  # 7
  ```

- `round(number, ndigits=None)`  
  四舍五入。
  ```python
  print(round(3.14159, 2))  # 3.14
  ```

- `pow(x, y, z=None)`  
  幂运算，等价于 `x ** y`。
  ```python
  print(pow(2, 3))  # 8
  ```

---

### 7.4. 序列与迭代
- `range(start, stop[, step])`  
  生成整数序列，常用于循环。
  ```python
  for i in range(1, 5):
      print(i)  # 1 2 3 4
  ```

- `enumerate(iterable, start=0)`  
  返回索引和值的元组。
  ```python
  for idx, val in enumerate(['a', 'b']):
      print(idx, val)  # 0 a  1 b
  ```

- `zip(*iterables)`  
  并行遍历多个序列。
  ```python
  for a, b in zip([1,2], ['x','y']):
      print(a, b)  # 1 x  2 y
  ```

- `sorted(iterable, key=None, reverse=False)`  
  返回排序后的新列表。
  ```python
  print(sorted([3,1,2]))  # [1, 2, 3]
  ```

- `reversed(seq)`  
  返回反向迭代器。
  ```python
  for i in reversed([1,2,3]):
      print(i)  # 3 2 1
  ```

---

### 7.5. 函数式编程
- `map(function, iterable)`  
  对序列中每个元素应用函数。
  ```python
  print(list(map(str.upper, ['a', 'b'])))  # ['A', 'B']
  ```

- `filter(function, iterable)`  
  过滤序列，保留使函数返回 True 的元素。
  ```python
  print(list(filter(lambda x: x > 0, [-1, 2, 0, 3])))  # [2, 3]
  ```

- `any(iterable)`  
  只要有一个元素为 True 就返回 True。
  ```python
  print(any([0, '', 3]))  # True
  ```

- `all(iterable)`  
  所有元素为 True 才返回 True。
  ```python
  print(all([1, 2, 3]))  # True
  print(all([1, 0, 3]))  # False
  ```

---

### 7.6. 其它常用函数
- `id(obj)`  
  返回对象的唯一标识（内存地址）。
  ```python
  print(id("abc"))
  ```

- `help(obj)`  
  查看对象的帮助文档。
  ```python
  help(str)
  ```

- `isinstance(obj, classinfo)`  
  判断对象是否为某类型。
  ```python
  print(isinstance(3, int))  # True
  ```

- `dir(obj)`  
  查看对象的所有属性和方法。
  ```python
  print(dir([]))
  ```

- `eval(expression)`  
  执行字符串表达式并返回结果。
  ```python
  print(eval("1+2"))  # 3
  ```

- `open(file, mode='r', encoding=None)`  
  打开文件，返回文件对象。
  ```python
  with open("test.txt", "w") as f:
      f.write("hello")
  ```

---


## 8. 模块与包

### 8.1 导入模块
#### Python 自定义导入的常见写法

1. **直接导入模块**
   ```python
   import mymodule
   mymodule.func()
   ```

2. **从模块中导入指定成员**
   ```python
   from mymodule import func, MyClass
   func()
   obj = MyClass()
   ```

3. **导入并重命名（起别名）**
   ```python
   import mymodule as mm
   mm.func()
   
   from mymodule import func as myfunc
   myfunc()
   ```

4. **导入包中的子模块或成员**
   ```python
   from mypackage import submodule
   from mypackage.submodule import func
   ```

5. **相对导入（仅限包内模块间）**
   ```python
   from . import sibling_module
   from .submodule import func
   from ..parent_module import func
   ```

6. **一次性导入多个成员**
   ```python
   from mymodule import func1, func2, MyClass
   ```

---

**注意：**
- 自定义模块就是 `.py` 文件，包是带有 `__init__.py` 的文件夹。
- 相对导入只能用于包结构内部，不能在顶层脚本直接使用。

## 9. 文件操作
```python
with open("test.txt", "w") as f:
    f.write("hello")

with open("test.txt", "r") as f:
    content = f.read()
    print(content)
```

---

## 10. 异常处理
```python
try:
    x = 1 / 0
except ZeroDivisionError:
    print("除零错误")
finally:
    print("结束")
```
- 常见异常：`ValueError`、`TypeError`、`IOError`、`KeyError` 等

---

## 11. 面向对象编程（OOP）

### 11.1 类和对象
```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(self.name + " 叫了一声")
    def __del__(self):
        print(f"{self.name} 被删除了")
dog = Animal("小狗")
dog.speak()
```

### 11.2 类属性与实例属性
```python
class Demo:
    count = 0  # 类属性

    def __init__(self):
        Demo.count += 1
        self.value = 10  # 实例属性
```

### 11.3 方法 —— 实例方法、类方法、静态方法详细总结

在 Python 的类中，方法分为三种：实例方法、类方法和静态方法。它们的区别如下：

#### 1. 实例方法（Instance Method）
- 定义时第一个参数必须是 `self`，代表实例对象本身。
- 只能通过对象调用，可以访问和修改实例属性。
- 最常用的方法类型。

**示例：**
```python
class Example:
    def instance_method(self):
        print("实例方法")
        print(self)
        
obj = Example()
obj.instance_method()  # 实例方法，self就是obj
```

#### 2. 类方法（Class Method）
- 用 `@classmethod` 装饰，第一个参数必须是 `cls`，代表类本身。
- 可以通过类或对象调用，常用于操作类属性或作为工厂方法。
- 不能直接访问实例属性，只能访问类属性。

**示例：**
```python
class Example:
    count = 0  # 类属性

    @classmethod
    def cls_method(cls): # cls代表 Example本身
        cls.count += 1
        print("类方法，当前count为：", cls.count)

Example.cls_method()  # 类方法，当前count为：1
obj = Example()
obj.cls_method()      # 类方法，当前count为：2
```

#### 3. 静态方法（Static Method）
- 用 `@staticmethod` 装饰，没有默认参数（不需要 self 或 cls）。
- 可以通过类或对象调用，通常用于工具函数，与类和实例都无关。
- 不能访问类属性和实例属性。

**示例：**
```python
class Example:
    @staticmethod
    def static_method():
        print("静态方法")

Example.static_method()
obj = Example()
obj.static_method()
```

---

#### 总结对比

| 方法类型   | 装饰器        | 第一个参数 | 访问实例属性 | 访问类属性 | 调用方式         |
| ---------- | ------------- | ---------- | ------------ | ---------- | ---------------- |
| 实例方法   | 无            | self       | 可以         | 可以       | 对象调用         |
| 类方法     | @classmethod  | cls        | 不可以       | 可以       | 类/对象都可调用  |
| 静态方法   | @staticmethod | 无         | 不可以       | 不可以     | 类/对象都可调用  |

---

**实际开发建议：**
- 需要访问或修改实例数据时用实例方法。
- 只操作类属性或需要工厂方法时用类方法。
- 与类和实例都无关的工具函数用静态方法。

### 11.4 继承与多态 详细总结（含常见坑）
- 继承实现代码复用和扩展，支持单继承和多继承。
- 多态让同一接口适配多种实现，提升代码灵活性。
- 注意多继承、super()、父类初始化等常见坑，编写高质量的面向对象代码。

#### 一、继承（Inheritance）

继承是面向对象编程（OOP）的核心特性，允许子类继承父类的属性和方法，实现代码复用和扩展。

- **基本语法：**
  ```python
  class Animal:
      def speak(self):
          print("动物叫")

  class Dog(Animal):
      def speak(self):
          print("狗汪汪叫")
  ```

- **特点：**
  - 子类自动拥有父类的所有属性和方法。
  - 子类可以重写（覆盖）父类的方法，实现自己的功能。
  - Python 支持多继承（一个类可以继承多个父类）。

- **super() 用法：**
  - 用于调用父类的方法，常见于子类重写 `__init__` 时。
```python
class Animal:
    def __init__(self, name):
        self.name = name
    def eat(self):
      print("吃")

class Dog(Animal):
    def __init__(self, name, age):
        super().__init__(name)  # 调用父类构造方法
        self.age = age
    def who(self):
        super().eat()
        print('我')


dog = Dog("小狗", 3)
dog.who()
```

- **多继承与方法解析顺序（MRO）：**
  - Python 使用 C3 线性化算法确定方法调用顺序。
  - 可通过 `类名.__mro__` 或 `类名.mro()` 查看。
  - 就近原则，再 D 中靠前的 B 里的相同方法，覆盖后面的相同方法

```python
class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        print("B")

class C(A):
    def show(self):
        print("C")

class D(B, C):
    pass

d = D()
d.show()  # 输出 B 就近原则，靠前的优先

print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

```

---

#### 二、多态（Polymorphism）

多态指“同一种行为，作用于不同对象时表现出不同的效果”。在 Python 中，主要通过继承和方法重写实现。

- **表现形式：**
  - 父类引用指向子类对象，调用方法时执行子类的实现。
  - 统一接口，灵活扩展。

- **示例：**
  ```python
  class Animal:
      def speak(self):
          print("动物叫")

  class Dog(Animal):
      def speak(self):
          print("狗汪汪叫")

  class Cat(Animal):
      def speak(self):
          print("猫喵喵叫")

  def animal_speak(animal):
      animal.speak()

  dog = Dog()
  cat = Cat()
  animal_speak(dog)  # 狗汪汪叫
  animal_speak(cat)  # 猫喵喵叫
  ```

- **优点：**
  - 增强代码灵活性和可扩展性。
  - 新增子类时无需修改调用代码，符合“开闭原则”。

---

#### 三、isinstance 和 issubclass

- `isinstance(obj, Class)`：判断对象是否是某个类或其子类的实例。
- `issubclass(Sub, Super)`：判断一个类是否是另一个类的子类。

**示例：**
```python
print(isinstance(dog, Animal))  # True
print(issubclass(Dog, Animal))  # True
```

---

#### 四、常见坑与注意事项

1. **子类重写父类方法时，参数列表要兼容，否则可能导致调用出错。**
   ```python
   class Base:
       def foo(self, x): pass
   class Sub(Base):
       def foo(self): pass  # 错误，缺少参数x
   ```

2. **多继承时，父类方法名冲突，调用顺序由 MRO 决定，注意避免菱形继承带来的混乱。**
   ```python
   class A:
       def show(self): print("A")
   class B(A):
       def show(self): print("B")
   class C(A):
       def show(self): print("C")
   class D(B, C): pass
   d = D()
   d.show()  # 输出 B，MRO顺序为 D->B->C->A
   print(D.mro())
   ```

3. **super() 只会按照 MRO 顺序调用下一个类的方法，不一定是父类本身。**
   - 在多继承下，`super()` 的行为可能和你预期不同。

4. **父类的私有属性（__attr）不会被子类继承。**
   - 因为双下划线属性会被名称重整（name mangling）。

5. **构造方法未调用父类的 `__init__`，父类属性不会自动初始化。**
   ```python
   class Parent:
       def __init__(self):
           self.x = 1
   class Child(Parent):
       def __init__(self):
           pass
   c = Child()
   print(c.x)  # 报错，x未初始化
   ```

6. **多态不是强制的，Python 是鸭子类型（duck typing），只要有同名方法即可。**
   - 但推荐通过继承实现接口统一，便于维护。

---

### 11.5 属性装饰器（@property）详细总结

属性装饰器（`@property`）是 Python 提供的一种将方法伪装成属性进行访问的机制，常用于对类的私有属性进行安全访问和控制。它可以让你像访问普通属性一样访问方法，同时可以自定义属性的读取、设置和删除行为。

- `@property` 让你可以像访问属性一样访问方法，增强了代码的封装性和灵活性。
- 适用于需要对属性访问进行控制的场景，是 Python 面向对象编程的重要特性之一。


#### 1. 基本用法

- 使用 `@property` 将一个方法变成只读属性。
- 使用 `@属性名.setter` 定义属性的设置方法。
- 使用 `@属性名.deleter` 定义属性的删除方法（可选）。

**示例：**
```python
class Person:
    def __init__(self, age):
        self._age = age  # 通常用单下划线表示“受保护”属性

    @property
    def age(self):
        """获取年龄"""
        return self._age

    @age.setter
    def age(self, value):
        """设置年龄"""
        if value < 0:
            raise ValueError("年龄不能为负数") # raise 抛出异常
        self._age = value

    @age.deleter
    def age(self):
        """删除年龄"""
        print("年龄已删除")
        del self._age

p = Person(18)
print(p.age)      # 18，实际调用的是 age() 方法
p.age = 20        # 实际调用的是 age.setter 方法
del p.age         # 实际调用的是 age.deleter 方法
```

#### 2. 作用与优点

- **封装性**：保护属性不被随意访问和修改。
- **兼容性**：可以在不改变外部接口的情况下，增加属性的校验逻辑。
- **只读属性**：只写 `@property`，不写 setter，即可实现只读属性。

#### 3. 常见场景

- 对属性进行类型检查、范围限制等校验。
- 只读属性（如身份证号、学号等）。
- 属性值的动态计算（如面积、体积等）。

**只读属性示例：**
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def area(self):
        return 3.14 * self._radius ** 2

c = Circle(5)
print(c.area)  # 78.5
# c.area = 100  # 报错：AttributeError: can't set attribute
```

#### 4. 注意事项

- 属性方法名要与装饰器一致（如 `@property`、`@age.setter`、`@age.deleter`）。
- 建议私有属性用单下划线 `_` 开头，避免与属性名冲突。
- 只定义 `@property` 不定义 setter，就是只读属性。

---


### 11.6 魔术方法
### 常用魔法方法（魔术方法）解释总结

魔法方法（Magic Methods），又称“特殊方法”或“dunder methods”，是 Python 中以双下划线 `__xxx__` 包围的方法。它们用于实现类的特殊行为，如初始化、运算符重载、对象表示、容器协议等。

#### 1. 对象创建与销毁
- `__init__(self, ...)`：对象初始化方法（构造函数），创建对象时自动调用。
- `__del__(self)`：对象销毁方法（析构函数），对象被回收时自动调用。

#### 2. 对象表示
- `__str__(self)`：定义 `str(obj)` 或 `print(obj)` 时的字符串表现。
- `__repr__(self)`：定义 `repr(obj)` 或直接输入对象时的表现，通常用于调试，要求更精确。

#### 3. 运算符重载
- `__add__(self, other)`：`+` 运算符
- `__sub__(self, other)`：`-` 运算符
- `__mul__(self, other)`：`*` 运算符
- `__truediv__(self, other)`：`/` 运算符
- `__floordiv__(self, other)`：`//` 运算符
- `__mod__(self, other)`：`%` 运算符
- `__pow__(self, other)`：`**` 运算符
- `__eq__(self, other)`：`==` 比较
- `__ne__(self, other)`：`!=` 比较
- `__lt__(self, other)`：`<` 比较
- `__le__(self, other)`：`<=` 比较
- `__gt__(self, other)`：`>` 比较
- `__ge__(self, other)`：`>=` 比较

#### 4. 容器相关
- `__len__(self)`：`len(obj)`，返回对象长度
- `__getitem__(self, key)`：`obj[key]`，获取元素
- `__setitem__(self, key, value)`：`obj[key] = value`，设置元素
- `__delitem__(self, key)`：`del obj[key]`，删除元素
- `__contains__(self, item)`：`item in obj`，成员判断

#### 5. 可迭代对象
- `__iter__(self)`：返回迭代器对象
- `__next__(self)`：返回下一个元素

#### 6. 上下文管理器
- `__enter__(self)`：进入 `with` 语句时调用
- `__exit__(self, exc_type, exc_val, exc_tb)`：退出 `with` 语句时调用

#### 7. 属性相关
- `__getattr__(self, name)`：访问不存在的属性时调用
- `__setattr__(self, name, value)`：设置属性时调用
- `__delattr__(self, name)`：删除属性时调用

#### 8. 调用对象
- `__call__(self, ...)`：使对象像函数一样可调用

---

#### 常用魔术方法详细示例

```python
class Demo:
    """ doc 属性的描述信息 """
    def __init__(self, x):
        self.x = x

    def __str__(self):
        # print(obj) 或 str(obj) 时调用
        return f"Demo({self.x})"

    def __repr__(self):
        # repr(obj) 或直接在解释器输入对象时调用
        return f"Demo<{self.x}>"

    def __len__(self):
        # len(obj) 时调用
        return self.x

    def __getitem__(self, key):
        # obj[key] 时调用
        return key * self.x

    def __setitem__(self, key, value):
        # obj[key] = value 时调用
        print(f"设置索引 {key} 的值为 {value}")

    def __delitem__(self, key):
        # del obj[key] 时调用
        print(f"删除索引 {key}")

    def __call__(self, y):
        # obj(y) 使对象像函数一样可调用
        return self.x + y

    def __eq__(self, other):
        # obj1 == obj2 时调用
        return self.x == other.x

d = Demo(5)
print(str(d))        # Demo(5)
print(repr(d))       # Demo<5>
print(len(d))        # 5
print(d[3])          # 15
d[1] = 100           # 设置索引 1 的值为 100
del d[2]             # 删除索引 2
print(d(10))         # 15
d2 = Demo(5)
print(d == d2)       # True
print(Demo.__doc__)  # doc 属性的描述信息
print(Demo.__module__) # 通过 import 导入时看从哪儿来的
print(Demo.__class__)  # 通过 import 导入时看从哪儿来的
```
```python
# 常见魔术方法和属性演示
class Demo:
    """这是一个演示类"""
    def __call__(self, x):
        print(f"调用对象，参数为{x}")

demo = Demo()
print(demo.__doc__)         # 输出类的文档字符串
print(demo.__module__)      # 输出模块名
print(demo.__class__)       # 输出对象所属的类
print(demo.__class__.__name__)  # 输出类名
demo(10)                    # 调用 __call__ 方法 使demo 对象可以执行
print(callable(demo))       # 判断对象是否可调用
```
---


#### 11.7 隐藏属性（私有属性）

在 Python 中，通过在属性名前加下划线 `_` 或双下划线 `__`，实现属性的“隐藏”或私有化。

- 单下划线 `_attr`：表示该属性是受保护的，建议只在类内部或子类中访问，外部仍可访问。
- 双下划线 `__attr`：实现名称重整（name mangling），外部无法直接访问，实际属性名变为 `_类名__attr`。

**示例：**
```python
class Person:
    def __init__(self, name, age):
        self.name = name        # 公有属性
        self._gender = "男"     # 受保护属性
        self.__salary = 10000   # 私有属性

p = Person("Tom", 20)
print(p.name)         # 正常访问
print(p._gender)      # 虽然能访问，但不建议
# print(p.__salary)   # 报错，无法直接访问
print(p._Person__salary)  # 可以通过“_类名__属性名”访问
```

---

#### 11.8. 销毁方法（__del__）

`__del__` 是对象的析构方法（销毁方法），当对象被垃圾回收时自动调用。常用于资源释放、日志记录等。
- `__del__` 方法不是必须的，只有在对象被回收时才会自动调用。
- 不建议在 `__del__` 里做复杂操作，避免资源未释放或异常。
**示例：**
```python
class Demo:
    def __init__(self, name):
        self.name = name
    def __del__(self):
        print(f"{self.name} 被销毁了")

d = Demo("测试对象")
del d  # 立即销毁并调用 __del__
```
### 11.9 单例模式

单例模式（Singleton Pattern）是一种常用的设计模式，保证一个类在程序运行期间只有一个实例，并提供一个全局访问点。

- 单例模式保证类只有一个实例，常用于资源管理、全局配置等场景。
- 推荐用 `__new__` 或装饰器实现，简单且易于理解。
- 单例模式适合全局唯一对象，滥用会导致代码难以测试和维护。
- 多线程环境下要注意线程安全（可加锁）。


#### 1. 为什么要用单例模式？
- 节省资源：如数据库连接、日志对象等只需一个实例。
- 保证数据一致性：全局唯一对象，避免状态混乱。

#### 2. Python 实现单例模式的常见方法

**方法一：重写 `__new__` 方法**
```python
class Singleton:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance

a = Singleton()
b = Singleton()
print(a is b)  # True，a和b是同一个对象
```

**方法二：装饰器实现**
```python
def singleton(cls):
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class MyClass:
    pass

x = MyClass()
y = MyClass()
print(x is y)  # True
```

**方法三：模块级单例**
- Python 的模块天然就是单例的，直接用模块变量即可。

---

## 12. 常用标准库
- `os`（操作系统）、`sys`（解释器）、`math`（数学）、`datetime`（日期时间）、`random`（随机）、`re`（正则）、`json`（JSON）、`logging`（日志）、`collections`（高级数据结构）等


### 1. os（操作系统相关）
- `os.getcwd()`：获取当前工作目录
- `os.chdir(path)`：切换目录
- `os.listdir(path)`：列出目录下所有文件
- `os.path.exists(path)`：判断路径是否存在
- `os.makedirs(path)`：递归创建目录
- `os.remove(path)`：删除文件
- `os.rename(src, dst)`：重命名文件或目录
- `os.environ`：环境变量字典

---

### 2. sys（解释器相关）
- `sys.argv`：命令行参数列表
- `sys.path`：模块搜索路径
- `sys.exit([arg])`：退出程序
- `sys.version`：Python 版本信息
- `sys.platform`：操作系统平台

---

### 3. math（数学运算）
- `math.ceil(x)`：向上取整
- `math.floor(x)`：向下取整
- `math.sqrt(x)`：平方根
- `math.pow(x, y)`：幂运算
- `math.sin(x)`、`math.cos(x)`、`math.tan(x)`：三角函数
- `math.pi`：圆周率常量

---

### 4. datetime（日期与时间）
- `datetime.datetime.now()`：当前日期时间
- `datetime.date.today()`：当前日期
- `datetime.datetime.strptime(str, fmt)`：字符串转日期
- `datetime.datetime.strftime(fmt)`：日期转字符串
- `datetime.timedelta(days=1)`：时间间隔

---

### 5. random（随机数）
- `random.randint(a, b)`：生成[a, b]范围内的整数
- `random.random()`：生成[0, 1)之间的随机浮点数
- `random.choice(seq)`：随机选取序列中的一个元素
- `random.shuffle(seq)`：原地打乱序列
- `random.sample(seq, n)`：从序列中随机取 n 个元素

---

### 6. re（正则表达式）
- `re.match(pattern, string)`：从头匹配
- `re.search(pattern, string)`：搜索整个字符串
- `re.findall(pattern, string)`：查找所有匹配
- `re.sub(pattern, repl, string)`：替换
- `re.compile(pattern)`：编译正则表达式，提高效率

---

### 7. json（JSON 处理）
- `json.dumps(obj)`：Python 对象转 JSON 字符串
- `json.loads(s)`：JSON 字符串转 Python 对象
- `json.dump(obj, fp)`：写入文件
- `json.load(fp)`：从文件读取

---

### 8. logging（日志）
- `logging.basicConfig(...)`：配置日志格式和级别
- `logging.debug/info/warning/error/critical(msg)`：不同级别日志输出
- `logging.getLogger(name)`：获取日志对象

---

### 9. collections（高级数据结构）
- `collections.Counter`：计数器
- `collections.defaultdict`：带默认值的字典
- `collections.OrderedDict`：有序字典（Python 3.7+ dict 默认有序）
- `collections.deque`：双端队列

---

**实际开发建议：**
- 文件和目录操作优先用 `os`。
- 命令行参数、退出程序用 `sys`。
- 时间处理用 `datetime`。
- 随机抽样、洗牌用 `random`。
- 文本匹配和提取用 `re`。
- 数据序列化和配置文件用 `json`。
- 日志记录用 `logging`。
- 复杂数据结构用 `collections`。


---


## 13. 第三方库与虚拟环境

### 13.1 pip 安装
```bash
pip install 包名
```

### 13.2 虚拟环境
```bash
python3 -m venv venv
source venv/bin/activate  # Mac/Linux
venv\Scripts\activate     # Windows
```

---

## 14. 代码规范
- 遵循 PEP8 编码规范，变量名小写加下划线，类名首字母大写。

---
