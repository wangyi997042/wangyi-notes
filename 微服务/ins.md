# 什么是微服务

**微服务（Microservices）** 是一种软件架构风格，将单一应用程序拆分为一组小型、独立部署的服务，每个服务围绕特定业务功能构建，并通过轻量级通信机制（如 HTTP/REST、RPC、消息队列等）进行交互。

---

## 微服务的核心特点

1. **单一职责**  
   每个服务只负责一个业务功能，代码简单、易于维护。

2. **独立部署**  
   各服务可独立开发、测试、部署和扩展，互不影响。

3. **技术多样性**  
   不同服务可用不同技术栈（如 Java、Python、Node.js），根据业务需求灵活选择。

4. **去中心化数据管理**  
   每个服务拥有自己的数据库，避免数据耦合。

5. **容错与弹性**  
   某个服务故障不会影响整个系统，易于实现高可用和自动恢复。

6. **自动化运维**  
   支持自动化测试、持续集成、容器化部署（如 Docker、Kubernetes）。

---

## 微服务与单体架构对比

| 单体架构 | 微服务架构 |
| --- | --- |
| 所有功能在一个应用内 | 每个功能拆分为独立服务 |
| 部署/升级需整体操作 | 可单独部署/升级某个服务 |
| 技术栈统一 | 可多技术栈混用 |
| 扩展性有限 | 易于横向扩展 |

---

## 微服务常见技术

- 服务注册与发现（如 Consul、Eureka）
- API 网关（如 Kong、Nginx、Spring Cloud Gateway）
- 配置中心（如 Spring Cloud Config、Apollo）
- 分布式追踪（如 Zipkin、Jaeger）
- 服务容器化与编排（如 Docker、Kubernetes）

---

## 微服务适用场景

- 大型、复杂、业务多变的系统
- 需要高可用、弹性伸缩的互联网平台
- 多团队协作、快速迭代的项目

---

**总结：**  
微服务架构让系统更灵活、可扩展、易维护，但也带来分布式系统的复杂性，需要合理设计和运维支持。


## 问题一：微服务是什么，相对于单体应用有什么优势？

### 1. 微服务的定义

微服务是一种**分布式架构设计理念**，核心是将原本单体架构下的大型应用，按照业务领域边界拆分为多个独立、自治的小型服务。每个服务专注于解决特定业务问题，拥有独立的开发、测试、部署、运行周期，服务间通过轻量级通信协议（如 HTTP/REST、gRPC）实现数据交互与协作，且可独立选择技术栈（如前端用 Vue、后端用 Java/Go）。

### 2. 微服务相对于单体应用的优势



* **扩展性更强**：单体应用需整体扩容（如增加服务器承载全量功能），而微服务可针对高负载服务单独扩容（如电商平台 “商品搜索” 服务访问量高，仅扩容该服务即可），资源利用率更高。

* **容错性更优**：单体应用一处故障（如订单模块 bug）可能导致整个系统崩溃；微服务中单个服务故障（如 “用户评论” 服务下线），可通过熔断、降级机制隔离，不影响核心业务（如支付、下单），系统稳定性更高。

* **开发效率更高**：单体应用代码量庞大、团队协作冲突多（如多团队修改同一模块）；微服务按业务拆分后，小团队可独立负责单个服务（如 “用户管理” 团队、“订单履约” 团队），开发周期短、迭代速度快，且支持并行开发。

* **技术栈更灵活**：单体应用通常受限于一种技术栈（如全栈用 Java），难以适配不同业务的技术需求（如实时通信适合用 Node.js，数据分析适合用 Python）；微服务可针对每个服务的场景选择最优技术栈，提升业务适配性。

* **维护成本更低**：单体应用后期维护需理解全量代码，复杂度高；微服务每个服务代码量少、业务边界清晰，问题定位（如日志仅需排查单个服务）、版本更新（如仅升级 “优惠券” 服务）更简单，降低维护难度。

## 问题二：为什么要给微服务限流，有哪些限流策略？

### 1. 微服务限流的原因

微服务架构下，服务间依赖关系复杂（如 “下单” 服务依赖 “库存”“支付”“物流” 等服务），且外部流量具有不可预测性（如促销活动、恶意攻击导致流量突增），限流的核心目标是**保护服务稳定运行，避免级联故障**，具体原因包括：



* **防止服务过载**：若某服务（如 “秒杀” 服务）突然接收远超其承载能力的请求（如每秒 10 万次请求，而服务仅能处理 1 万次 / 秒），会导致 CPU、内存、线程耗尽，服务响应变慢甚至宕机。

* **避免级联故障**：微服务是 “链式依赖”，若上游服务（如 “商品” 服务）因过载宕机，会导致依赖它的下游服务（如 “下单”“购物车” 服务）请求堆积，进而引发下游服务也过载宕机，形成 “雪崩效应”，限流可从源头阻断该链条。

* **保障核心业务**：系统资源有限时，限流可优先保障核心业务（如电商平台优先允许 “支付”“下单” 请求通过，限制 “商品浏览”“评论” 等非核心请求），避免非核心业务占用资源导致核心业务不可用。

* **应对恶意攻击**：限流可抵御简单的流量攻击（如 DDoS 攻击、爬虫高频请求），通过限制单 IP / 单用户的请求频率，减少恶意流量对服务的冲击。

### 2. 常见的限流策略

#### （1）计数器法（固定窗口）



* **原理**：设定一个时间窗口（如 1 分钟）和窗口内的请求上限（如 100 次），用计数器统计窗口内的请求数；若请求数达到上限，后续请求直接拒绝，窗口结束后计数器清零重新计数。

* **特点**：实现简单（如用 Redis 的 incr 命令统计），但存在 “窗口边界” 问题（如窗口 1 分钟限 100 次，第 59 秒和第 61 秒分别发送 100 次请求，实际 2 秒内有 200 次请求，突破限制）。

* **适用场景**：对限流精度要求不高的场景（如非核心服务的接口限流）。

#### （2）滑动窗口法



* **原理**：将固定时间窗口拆分为多个更小的 “子窗口”（如 1 分钟拆分为 60 个 1 秒子窗口），每个子窗口独立计数；统计时取 “当前时间向前推 1 分钟” 的所有子窗口请求总和，若超过上限则限流。

* **特点**：解决了固定窗口的 “边界问题”，限流精度更高，但实现复杂度略增（需维护多个子窗口的计数）。

* **适用场景**：对限流精度有一定要求的场景（如用户登录、短信发送接口）。

#### （3）令牌桶算法



* **原理**：系统按固定速率（如每秒生成 10 个令牌）向 “令牌桶” 中放入令牌，桶内有最大容量（如最多存 50 个令牌，满了则不再生成）；请求到达时需从桶中获取 1 个令牌，获取成功则允许访问，无令牌则拒绝 / 排队。

* **特点**：支持 “突发流量”（桶内积累的令牌可应对短时间的流量峰值），且能平滑限制长期平均流量，灵活性高。

* **适用场景**：大多数微服务场景，尤其是允许一定突发流量的接口（如商品详情查询、订单提交）。

#### （4）漏桶算法



* **原理**：将请求比作 “水流”，“漏桶” 有固定容量和固定流出速率（如每秒流出 10 个请求）；请求到达时先进入漏桶，若桶未满则接收，若桶满则拒绝；漏桶按固定速率将请求 “漏出” 给服务处理。

* **特点**：严格限制请求的流出速率，无论输入流量是否突发，输出速率始终平稳，可避免服务因突发流量被冲击，但不支持突发流量的合理利用。

* **适用场景**：需严格控制输出速率的场景（如数据库访问接口，避免高并发请求压垮数据库）。
