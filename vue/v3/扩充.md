以下是在原有基础上补充完善的 **Vue 3 核心知识点总结**，新增了错误处理、边界情况、自定义指令进阶、响应式工具等内容，并补充了更多实用示例：


# Vue 3 核心知识点总结（补充版）


## **1. Vue Router（路由管理）**

### **补充：路由懒加载**  
通过动态 `import` 实现组件按需加载，减少初始包体积：  
```javascript
// 路由配置中使用懒加载
const routes = [
  { 
    path: '/home', 
    component: () => import('@/views/Home.vue') // 懒加载组件
  },
  { 
    path: '/about', 
    component: () => import(/* webpackChunkName: "about" */ '@/views/About.vue') // 自定义chunk名称
  }
];
```

### **补充：编程式导航进阶**  
除了 `push`，还有 `replace`（替换历史记录）和 `go`（前进/后退）：  
```javascript
import { useRouter } from 'vue-router';

const router = useRouter();

// 替换当前路由（不新增历史记录）
router.replace('/login');

// 前进/后退（类似window.history）
router.go(1); // 前进1步
router.go(-1); // 后退1步
```

### **补充：查询参数（query）**  
用于传递非动态路由的参数（显示在URL查询字符串中）：  
```javascript
// 跳转时携带query
router.push({ path: '/search', query: { keyword: 'vue' } });

// 获取query参数
const route = useRoute();
console.log(route.query.keyword); // 输出 'vue'
```


## **2. Pinia（状态管理）**

### **补充：状态持久化**  
使用 `pinia-plugin-persistedstate` 实现状态本地存储（刷新不丢失）：  
```bash
npm install pinia-plugin-persistedstate
```

```javascript
// main.js 注册插件
import { createPinia } from 'pinia';
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate';

const pinia = createPinia();
pinia.use(piniaPluginPersistedstate);

// 定义带持久化的store
const useUserStore = defineStore('user', {
  state: () => ({ token: '', userInfo: {} }),
  actions: {
    setToken(token) { this.token = token; }
  },
  persist: true // 开启持久化（默认存储在localStorage）
});
```

### **补充：Store 间通信**  
不同 Store 可直接调用对方的方法或状态：  
```javascript
// userStore.js
export const useUserStore = defineStore('user', {
  state: () => ({ userId: 1 }),
});

// cartStore.js
import { useUserStore } from './userStore';
export const useCartStore = defineStore('cart', {
  actions: {
    async fetchCart() {
      const userStore = useUserStore();
      const res = await api.get(`/cart?userId=${userStore.userId}`); // 调用其他store的状态
    }
  }
});
```


## **3. Composition API（组合式API）**

### **补充：生命周期钩子**  
在 `setup` 中使用生命周期钩子（需从vue导入）：  
```javascript
import { onMounted, onUnmounted, onUpdated } from 'vue';

setup() {
  // 组件挂载后执行
  onMounted(() => {
    console.log('组件已挂载');
    window.addEventListener('scroll', handleScroll);
  });

  // 组件更新后执行
  onUpdated(() => {
    console.log('组件已更新');
  });

  // 组件卸载前执行（清理副作用）
  onUnmounted(() => {
    console.log('组件即将卸载');
    window.removeEventListener('scroll', handleScroll);
  });

  function handleScroll() { /* ... */ }
}
```

### **补充：provide/inject 跨层通信**  
用于爷孙组件、深层组件通信：  
```javascript
// 父组件（提供数据）
import { provide } from 'vue';

setup() {
  const theme = ref('dark');
  // 提供数据（key, value）
  provide('theme', theme);
}

// 子/孙组件（注入数据）
import { inject } from 'vue';

setup() {
  // 注入数据（key, 默认值）
  const theme = inject('theme', ref('light'));
  return { theme };
}
```

### **补充：customRef 自定义响应式**  
实现带防抖的输入框响应式：  
```javascript
import { customRef } from 'vue';

function useDebouncedRef(value, delay = 300) {
  let timeout;
  return customRef((track, trigger) => {
    return {
      get() {
        track(); // 追踪依赖
        return value;
      },
      set(newVal) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          value = newVal;
          trigger(); // 触发更新
        }, delay);
      }
    };
  });
}

// 使用
setup() {
  const searchText = useDebouncedRef(''); // 输入300ms后才更新
  return { searchText };
}
```


## **4. 动画与过渡**

### **补充：列表过渡（transition-group）**  
实现列表项增删动画：  
```html
<template>
  <transition-group name="list" tag="ul">
    <li v-for="item in items" :key="item.id">
      {{ item.name }}
      <button @click="remove(item.id)">删除</button>
    </li>
  </transition-group>
  <button @click="add">添加项</button>
</template>

<script setup>
import { ref } from 'vue';
let id = 3;
const items = ref([
  { id: 1, name: '项1' },
  { id: 2, name: '项2' }
]);
const add = () => items.value.push({ id: id++, name: `项${id}` });
const remove = (id) => items.value = items.value.filter(i => i.id !== id);
</script>

<style>
/* 列表项过渡样式 */
.list-enter-active, .list-leave-active {
  transition: all 0.3s ease;
}
.list-enter-from, .list-leave-to {
  opacity: 0;
  transform: translateY(10px);
}
</style>
```

### **补充：JS 钩子动画**  
通过JS控制动画细节（如结合GSAP）：  
```html
<transition
  @before-enter="beforeEnter"
  @enter="enter"
  @leave="leave"
>
  <div v-if="show" ref="box" class="box"></div>
</transition>

<script setup>
import { ref } from 'vue';
import gsap from 'gsap';

const show = ref(false);
const box = ref(null);

const beforeEnter = (el) => {
  el.style.opacity = 0;
  el.style.transform = 'scale(0)';
};

const enter = (el, done) => {
  gsap.to(el, {
    opacity: 1,
    scale: 1,
    duration: 0.5,
    onComplete: done // 必须调用done通知动画结束
  });
};

const leave = (el, done) => {
  gsap.to(el, {
    opacity: 0,
    scale: 0,
    duration: 0.5,
    onComplete: done
  });
};
</script>
```


## **5. 异步组件与 Suspense**

### **补充：与 Suspense 结合使用**  
`Suspense` 用于等待异步组件加载，显示 fallback 内容：  
```html
<!-- 父组件 -->
<template>
  <Suspense>
    <!-- 异步组件（需要等待的内容） -->
    <AsyncComponent />
    <!-- 加载中显示的内容 -->
    <template #fallback>
      <div>加载中...</div>
    </template>
  </Suspense>
</template>

<script setup>
import { defineAsyncComponent } from 'vue';
// 定义异步组件
const AsyncComponent = defineAsyncComponent(() => import('./AsyncComp.vue'));
</script>

<!-- AsyncComp.vue（异步组件） -->
<script setup>
// 组件内部可以有异步操作（如API请求）
const data = await fetch('/api/data').then(res => res.json());
</script>
```


## **6. 性能优化**

### **补充：memo 组件（缓存组件）**  
避免组件不必要的重渲染（类似React.memo）：  
```html
<template>
  <!-- 只有当 props 变化时才重新渲染 -->
  <MemoizedComponent :count="count" />
</template>

<script setup>
import { ref, memo } from 'vue';
// 普通组件
const MyComponent = ({ count }) => {
  console.log('组件渲染了');
  return <div>{count}</div>;
};
// 缓存组件（仅当count变化时重新渲染）
const MemoizedComponent = memo(MyComponent, (prevProps, nextProps) => {
  return prevProps.count === nextProps.count; // 自定义比较逻辑
});

const count = ref(0);
</script>
```

### **补充：shallowRef 与 shallowReactive**  
用于优化深层对象的响应式性能（只监听顶层属性）：  
```javascript
// shallowRef：只监听 .value 的变化，不监听内部属性
const shallow = shallowRef({ a: 1 });
shallow.value.a = 2; // 不会触发更新
shallow.value = { a: 2 }; // 会触发更新

// shallowReactive：只监听顶层属性，不监听嵌套属性
const shallowObj = shallowReactive({ a: { b: 1 } });
shallowObj.a.b = 2; // 不会触发更新
shallowObj.a = { b: 2 }; // 会触发更新
```


## **7. 错误处理**

### **全局错误处理**  
捕获应用内所有未处理的错误（包括组件渲染、事件回调等）：  
```javascript
// main.js
const app = createApp(App);
app.config.errorHandler = (err, instance, info) => {
  console.error('全局错误捕获:', err);
  console.log('组件实例:', instance);
  console.log('错误信息:', info); // 如 "render" 表示渲染时出错
  // 可在这里上报错误到服务端
};
```

### **组件内错误捕获**  
通过 `onErrorCaptured` 捕获子组件错误：  
```javascript
import { onErrorCaptured } from 'vue';

setup() {
  onErrorCaptured((err, instance, info) => {
    console.log('子组件错误:', err);
    // 返回 true 阻止错误继续向上传播
    return true;
  });
}
```

### **异步错误处理**  
在 `setup` 或 `actions` 中处理异步错误：  
```javascript
// 组件中
setup() {
  const loadData = async () => {
    try {
      const res = await fetch('/api/data');
      if (!res.ok) throw new Error('请求失败');
      return res.json();
    } catch (err) {
      console.error('异步错误:', err);
    }
  };
}

// Pinia actions 中
const useDataStore = defineStore('data', {
  actions: {
    async fetchData() {
      try {
        this.data = await api.getData();
      } catch (err) {
        this.error = err.message;
      }
    }
  }
});
```


## **8. 边界情况处理**

### **Teleport（传送门）**  
将组件内容渲染到DOM的指定位置（如模态框避免样式嵌套问题）：  
```html
<template>
  <button @click="show = true">打开弹窗</button>
  <teleport to="body"> <!-- 渲染到body下 -->
    <div v-if="show" class="modal">
      <p>这是弹窗内容</p>
      <button @click="show = false">关闭</button>
    </div>
  </teleport>
</template>

<script setup>
import { ref } from 'vue';
const show = ref(false);
</script>
```

### **Fragment（片段）**  
Vue 3 自动支持多根节点（无需额外包裹div）：  
```html
<template>
  <h1>标题</h1>
  <p>内容1</p>
  <p>内容2</p>
</template>
<!-- 编译后自动包裹在Fragment中，不会生成多余DOM -->
```

### **v-pre 指令**  
跳过元素的编译过程（用于显示原始模板内容）：  
```html
<div v-pre>
  {{ 这部分不会被编译，会原样显示 }}
</div>
```


## **9. 自定义指令进阶**

### **示例：v-copy（一键复制文本）**  
```javascript
// 注册全局指令
app.directive('copy', {
  mounted(el, binding) {
    el.addEventListener('click', () => {
      navigator.clipboard.writeText(binding.value)
        .then(() => {
          alert('复制成功');
        })
        .catch(() => {
          alert('复制失败');
        });
    });
  }
});

// 使用
<button v-copy="textToCopy">复制</button>
```

### **示例：v-click-outside（点击外部关闭）**  
```javascript
app.directive('click-outside', {
  mounted(el, binding) {
    const handleClick = (e) => {
      if (!el.contains(e.target)) {
        binding.value(); // 执行绑定的方法
      }
    };
    document.addEventListener('click', handleClick);
    // 卸载时移除事件
    el._clickOutsideHandler = handleClick;
  },
  unmounted(el) {
    document.removeEventListener('click', el._clickOutsideHandler);
  }
});

// 使用（关闭弹窗）
<div v-if="show" v-click-outside="() => show = false">弹窗内容</div>
```


## **10. 响应式工具**  
用于判断响应式数据类型：  
```javascript
import { isRef, isReactive, isProxy } from 'vue';

const a = ref(1);
const b = reactive({});
const c = 123;

console.log(isRef(a)); // true
console.log(isReactive(b)); // true
console.log(isProxy(b)); // true（reactive基于Proxy实现）
console.log(isRef(c)); // false
```
