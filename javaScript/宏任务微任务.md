
# JavaScript 事件循环：宏任务与微任务详解

## 一、基本概念

在JavaScript中，任务（Task）被分为**宏任务（Macrotask）**和**微任务（Microtask）**，这是理解事件循环（Event Loop）的关键。

### 1. 为什么需要区分宏任务和微任务？

同步任务和异步任务的划分其实并不准确。准确的分类方式是宏任务（Macrotask）和微任务（Microtask）。

## 二、宏任务与微任务的分类

### 1. 宏任务（Macrotask）包括：
- `script(整体代码)`
- `setTimeout`
- `setInterval`
- `requestAnimationFrame`
- `I/O`（如文件读写、网络请求）
- `setImmediate`（只存在于Node.js中）
- `requestIdleCallback`（浏览器API）

> **注意**：
> - `setImmediate`只存在于Node.js中
> - `requestAnimationFrame`只存在于浏览器中

### 2. 微任务（Microtask）包括：
- `Promise`
- `Object.observe`（已废弃，不推荐使用）
- `MutationObserver`（HTML5新特性，只存在于浏览器中）
- `process.nextTick`（只存在于Node.js中）

> **注意**：
> - `process.nextTick`只存在于Node.js中
> - `MutationObserver`只存在于浏览器中

### 3. UI Rendering 的位置

UI Rendering不属于宏任务，也不属于微任务，它是一个与微任务平行的操作步骤。

## 三、执行顺序

### 1. 事件循环的基本执行方式

1. 执行一个宏任务（Macrotask）
2. 在执行过程中，如果遇到微任务（Microtask），将其放入微任务队列
3. 当前宏任务执行完成后，查看微任务队列，依次执行里面的微任务
4. 如果还有宏任务，再重新开启宏任务...

### 2. 事件循环流程图

![alt 属性文本](./image/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1.jpg)
```
执行一个宏任务
  │
  ▼
执行过程中遇到微任务 → 放入微任务队列
  │
  ▼
宏任务执行完成
  │
  ▼
执行微任务队列中的所有微任务
  │
  ▼
开始下一轮循环（如果有宏任务）
```

## 四、执行示例

### 1. 基础示例

```javascript
setTimeout(function () { console.log("a"); });
new Promise(function (resolve) {
  console.log("b");
  for (var i = 0; i < 10000; i++) {
    i == 99 && resolve();
  }
}).then(function () { console.log("c"); });
console.log("d");
```

**执行顺序**：
1. 首先执行script下的宏任务
2. 遇到setTimeout，将其放入宏任务队列
3. 遇到Promise，new Promise直接执行，打印"b"
4. 遇到then方法，是微任务，将其放到微任务队列
5. 遇到console.log('d')，直接打印"d"
6. 本轮宏任务执行完毕，查看微任务，发现then方法里的函数，打印"c"
7. 本轮event loop全部完成
8. 下一轮循环，先执行宏任务，发现宏任务队列中有一个setTimeout，打印"a"

**输出结果**：
```
b
d
c
a
```

### 2. 进阶示例

```javascript
console.log("a");
setTimeout(function () {
  console.log("b");
  process.nextTick(function () {
    console.log("c");
  });
  new Promise(function (resolve) {
    console.log("d");
    resolve();
  }).then(function () {
    console.log("e");
  });
});
process.nextTick(function () {
  console.log("f");
});
new Promise(function (resolve) {
  console.log("g");
  resolve();
}).then(function () {
  console.log("h");
});
setTimeout(function () {
  console.log("i");
  process.nextTick(function () {
    console.log("j");
  });
  new Promise(function (resolve) {
    console.log("k");
    resolve();
  }).then(function () {
    console.log("l");
  });
});
```

**执行分析**：

**第一轮事件循环**：
1. 执行script整体代码
   - `console.log('a')` → 打印"a"
   - `setTimeout` → 回调函数放入宏任务队列（setTimeout1）
   - `process.nextTick` → 回调函数放入微任务队列（process1）
   - `new Promise` → 直接执行，打印"g"
   - `then` → 放入微任务队列（then1）
   - `setTimeout` → 回调函数放入宏任务队列（setTimeout2）
   
   **任务队列状态**：
   - 宏任务队列：setTimeout1, setTimeout2
   - 微任务队列：process1, then1

2. 宏任务执行完毕，执行微任务
   - 执行process1 → 打印"f"
   - 执行then1 → 打印"h"
   
   **输出结果**：a, g, f, h

**第二轮事件循环**：
1. 执行setTimeout1宏任务
   - `console.log('b')` → 打印"b"
   - `process.nextTick` → 放入微任务队列（process2）
   - `new Promise` → 直接执行，打印"d"
   - `then` → 放入微任务队列（then2）
   
   **任务队列状态**：
   - 宏任务队列：setTimeout2
   - 微任务队列：process2, then2

2. 宏任务执行完毕，执行微任务
   - 执行process2 → 打印"c"
   - 执行then2 → 打印"e"
   
   **输出结果**：b, d, c, e

**第三轮事件循环**：
1. 执行setTimeout2宏任务
   - `console.log('i')` → 打印"i"
   - `process.nextTick` → 放入微任务队列（process3）
   - `new Promise` → 直接执行，打印"k"
   - `then` → 放入微任务队列（then3）
   
   **任务队列状态**：
   - 宏任务队列：空
   - 微任务队列：process3, then3

2. 宏任务执行完毕，执行微任务
   - 执行process3 → 打印"j"
   - 执行then3 → 打印"l"
   
   **输出结果**：i, k, j, l

**最终输出结果**：
```
a
g
f
h
b
d
c
e
i
k
j
l
```

## 五、关键总结

1. **执行顺序**：宏任务 → 微任务 → 宏任务 → 微任务...

2. **宏任务 vs 微任务**：
   - 宏任务：setTimeout, setInterval, I/O, UI Rendering
   - 微任务：Promise, MutationObserver, process.nextTick

3. **重要规则**：
   - 每个宏任务执行完后，会执行完当前微任务队列的所有任务
   - 微任务在宏任务之间执行，而不是在宏任务内部

4. **常见误区**：
   - "a是最持久的" - 这个说法是错误的，根据上面的例子，"l"是最持久的
   - UI Rendering不属于宏任务，也不属于微任务

5. **浏览器与Node.js的差异**：
   - Node.js中：有`setImmediate`和`process.nextTick`
   - 浏览器中：有`requestAnimationFrame`和`MutationObserver`

## 六、实际应用

### 1. 如何优化代码执行顺序

```javascript
// 优化代码执行顺序
function doSomething() {
  // 一些操作
  console.log("操作完成");
  
  // 用微任务确保在当前宏任务完成后执行
  Promise.resolve().then(() => {
    console.log("微任务执行");
  });
}
```

### 2. 解决UI渲染问题

```javascript
// 避免在渲染过程中进行复杂计算
function updateUI() {
  // 先进行数据处理
  const data = processData();
  
  // 用微任务确保在当前宏任务完成后更新UI
  Promise.resolve().then(() => {
    renderUI(data);
  });
}
```

## 七、常见问题

### 1. 为什么Promise的then回调是微任务？

Promise的then回调被设计为微任务，是为了确保在当前宏任务执行完成后，但在下一个宏任务开始前执行，保证了异步操作的有序性。

### 2. 为什么process.nextTick是微任务？

`process.nextTick`是Node.js特有的API，它的设计目的是在当前事件循环的末尾、下一个事件循环开始之前执行，因此它被归类为微任务。

### 3. 为什么setTimeout比Promise的then先执行？

因为setTimeout是宏任务，而Promise的then是微任务。宏任务在微任务之前执行，但每个宏任务执行完成后，会先执行所有微任务，然后再执行下一个宏任务。

## 八、总结

- JavaScript的事件循环基于宏任务和微任务的执行顺序
- 宏任务包括：script, setTimeout, setInterval, I/O, setImmediate
- 微任务包括：Promise, MutationObserver, process.nextTick
- 执行顺序：宏任务 → 微任务 → 宏任务 → 微任务...
- UI Rendering是与微任务平行的操作步骤
- 理解宏任务和微任务的执行顺序，对于编写高性能、可预测的异步代码至关重要
